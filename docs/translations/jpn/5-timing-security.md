[← 前へ: フォージング割り当て](4-forging-assignments.md) | [目次](index.md) | [次へ: ネットワークパラメータ →](6-network-parameters.md)

---

# 第5章: 時刻同期とセキュリティ

## 概要

PoCXコンセンサスはネットワーク全体で正確な時刻同期を必要とします。本章では、時間関連のセキュリティメカニズム、クロックドリフト許容範囲、および防御的フォージング動作について説明します。

**主要メカニズム**:
- ブロックタイムスタンプに対する15秒の将来許容範囲
- 10秒のクロックドリフト警告システム
- 防御的フォージング（クロック操作対策）
- タイムベンディングアルゴリズムの統合

---

## 目次

1. [時刻同期要件](#時刻同期要件)
2. [クロックドリフト検出と警告](#クロックドリフト検出と警告)
3. [防御的フォージングメカニズム](#防御的フォージングメカニズム)
4. [セキュリティ脅威分析](#セキュリティ脅威分析)
5. [ノード運用者向けベストプラクティス](#ノード運用者向けベストプラクティス)

---

## 時刻同期要件

### 定数とパラメータ

**Bitcoin-PoCX設定:**
```cpp
// src/chain.h:31
static constexpr int64_t MAX_FUTURE_BLOCK_TIME = 15;  // 15秒

// src/node/timeoffsets.h:27
static constexpr std::chrono::seconds WARN_THRESHOLD{10};  // 10秒
```

### 検証チェック

**ブロックタイムスタンプ検証** (`src/validation.cpp:4547-4561`):
```cpp
// 1. 単調チェック: タイムスタンプ >= 前のブロックのタイムスタンプ
if (block.nTime < pindexPrev->nTime) {
    return state.Invalid("time-too-old");
}

// 2. 将来チェック: タイムスタンプ <= 現在時刻 + 15秒
if (block.Time() > NodeClock::now() + std::chrono::seconds{MAX_FUTURE_BLOCK_TIME}) {
    return state.Invalid("time-too-new");
}

// 3. デッドラインチェック: 経過時間 >= デッドライン
uint32_t elapsed_time = block.nTime - pindexPrev->nTime;
if (result.deadline > elapsed_time) {
    return state.Invalid("bad-pocx-timing");
}
```

### クロックドリフト影響表

| クロックオフセット | 同期可能? | マイニング可能? | 検証ステータス | 競争上の効果 |
|--------------|-----------|-----------|-------------------|-------------------|
| -30秒遅れ | 不可 - 将来チェック失敗 | N/A | **死亡ノード** | 参加不可 |
| -14秒遅れ | 可能 | 可能 | 遅いフォージング、検証通過 | レースに敗北 |
| 0秒正確 | 可能 | 可能 | 最適 | 最適 |
| +14秒進み | 可能 | 可能 | 早いフォージング、検証通過 | レースに勝利 |
| +16秒進み | 可能 | 不可 - 将来チェック失敗 | ブロック伝播不可 | 同期可能、マイニング不可 |

**重要な洞察**: 15秒ウィンドウは参加については対称的（±14.9秒）ですが、高速クロックは許容範囲内で不公平な競争優位性を提供します。

### タイムベンディング統合

タイムベンディングアルゴリズム（[第3章](3-consensus-and-mining.md#タイムベンディング計算)で詳細説明）は立方根を使用して生のデッドラインを変換します:

```
time_bended_deadline = scale × (deadline_seconds)^(1/3)
```

**クロックドリフトとの相互作用**:
- より良い解はより早くフォージ（立方根は品質差を増幅）
- クロックドリフトはネットワークに対するフォージング時間に影響
- 防御的フォージングはタイミング分散にもかかわらず品質ベースの競争を保証

---

## クロックドリフト検出と警告

### 警告システム

Bitcoin-PoCXはローカルノードとネットワークピア間の時間オフセットを監視します。

**警告メッセージ**（ドリフトが10秒を超えた場合）:
> "コンピュータの日付と時刻がネットワークと10秒以上ずれているようです。これはPoCXコンセンサス障害につながる可能性があります。システム時刻を確認してください。"

**実装**: `src/node/timeoffsets.cpp`

### 設計根拠

**なぜ10秒?**
- 15秒許容限界の前に5秒の安全バッファを提供
- Bitcoin Coreのデフォルト（10分）より厳しい
- PoCタイミング要件に適切

**予防的アプローチ**:
- 重大な障害の前に早期警告
- 運用者が問題を事前に修正可能
- 時間関連の障害によるネットワーク断片化を軽減

---

## 防御的フォージングメカニズム

### 概要

防御的フォージングはBitcoin-PoCXの標準マイナー動作であり、ブロック生成におけるタイミングベースの優位性を排除します。マイナーが同じ高さで競合ブロックを受信すると、自動的により良い解を持っているかチェックします。もし持っていれば、即座に自分のブロックをフォージし、クロック操作ベースの競争ではなく品質ベースの競争を保証します。

### 問題

PoCXコンセンサスは最大15秒先までのタイムスタンプを持つブロックを許可します。この許容範囲はグローバルネットワーク同期に必要です。しかし、クロック操作の機会を生み出します:

**防御的フォージングなしの場合:**
- マイナーA: 正確な時刻、品質800（より良い）、適切なデッドラインまで待機
- マイナーB: 高速クロック（+14秒）、品質1000（より悪い）、14秒早くフォージ
- 結果: マイナーBは劣った容量証明作業にもかかわらずレースに勝利

**問題点:** クロック操作は悪い品質でも優位性を提供し、容量証明の原則を損なう。

### 解決策: 2層防御

#### 第1層: クロックドリフト警告（予防的）

Bitcoin-PoCXはノードとネットワークピア間の時間オフセットを監視します。クロックがネットワークコンセンサスから10秒以上ずれると、クロック問題が問題を引き起こす前に修正するよう警告を受け取ります。

#### 第2層: 防御的フォージング（反応的）

別のマイナーがあなたがマイニングしているのと同じ高さでブロックを公開すると:

1. **検出**: ノードが同じ高さの競争を識別
2. **検証**: 競合ブロックの品質を抽出して検証
3. **比較**: 自分の品質がより良いかチェック
4. **応答**: より良ければ、即座にブロックをフォージ

**結果:** ネットワークは両方のブロックを受信し、標準フォーク解決を通じてより良い品質のものを選択。

### 動作の詳細

#### シナリオ: 同じ高さの競争

```
時間150秒: マイナーB（クロック+10秒）が品質1000でフォージ
           → ブロックタイムスタンプは160秒を表示（10秒先）

時間150秒: あなたのノードがマイナーBのブロックを受信
           → 検出: 同じ高さ、品質1000
           → あなたの品質: 800（より良い!）
           → アクション: 正しいタイムスタンプ（150秒）で即座にフォージ

時間152秒: ネットワークが両ブロックを検証
           → 両方有効（15秒許容範囲内）
           → 品質800が勝利（低い = より良い）
           → あなたのブロックがチェーンティップになる
```

#### シナリオ: 真の再編成

```
あなたのマイニング高さ100、競合者がブロック99を公開
→ 同じ高さの競争ではない
→ 防御的フォージングは発動しない
→ 通常の再編成処理が進行
```

### 利点

**クロック操作へのインセンティブゼロ**
- 高速クロックは既に最良の品質を持っている場合にのみ役立つ
- クロック操作は経済的に無意味になる

**品質ベース競争の強制**
- マイナーに実際の容量証明作業での競争を強制
- PoCXコンセンサスの整合性を保持

**ネットワークセキュリティ**
- タイミングベースのゲーム戦略に耐性
- コンセンサス変更不要 - 純粋なマイナー動作

**完全自動**
- 設定不要
- 必要な時のみ発動
- すべてのBitcoin-PoCXノードの標準動作

### トレードオフ

**最小限のオーファン率増加**
- 意図的 - 攻撃ブロックはオーファンになる
- 実際のクロック操作試行時のみ発生
- 品質ベースフォーク解決の自然な結果

**短時間のネットワーク競争**
- ネットワークは一時的に2つの競合ブロックを見る
- 標準検証で数秒で解決
- Bitcoinの同時マイニングと同じ動作

### 技術詳細

**パフォーマンス影響:** 無視できる
- 同じ高さの競争でのみ発動
- メモリ内データを使用（ディスクI/Oなし）
- 検証はミリ秒で完了

**リソース使用:** 最小限
- 約20行のコアロジック
- 既存の検証インフラストラクチャを再利用
- 単一ロック取得

**互換性:** 完全
- コンセンサスルール変更なし
- すべてのBitcoin Core機能と動作
- デバッグログによるオプション監視

**ステータス**: すべてのBitcoin-PoCXリリースでアクティブ
**初回導入**: 2025年10月10日

---

## セキュリティ脅威分析

### 高速クロック攻撃（防御的フォージングで軽減）

**攻撃ベクトル**:
クロックが**+14秒進んでいる**マイナーは:
1. ブロックを正常に受信（彼らには古く見える）
2. デッドラインが過ぎると即座にブロックをフォージ
3. ネットワークに14秒「早く」見えるブロックをブロードキャスト
4. **ブロックは受け入れられる**（15秒許容範囲内）
5. 正直なマイナーに対して**レースに勝利**

**防御的フォージングなしの場合の影響**:
優位性は14.9秒に制限され（重大なPoC作業をスキップするには不十分）、ブロックレースで一貫した優位性を提供。

**軽減（防御的フォージング）**:
- 正直なマイナーが同じ高さの競争を検出
- 品質値を比較
- 品質がより良ければ即座にフォージ
- **結果**: 高速クロックは既に最良の品質を持っている場合にのみ役立つ
- **インセンティブ**: ゼロ - クロック操作は経済的に無意味

### 低速クロック障害（重大）

**障害モード**:
**15秒以上遅れている**ノードは壊滅的:
- 受信ブロックを検証不可（将来チェック失敗）
- ネットワークから分離
- マイニングも同期も不可

**軽減**:
- 10秒ドリフトでの強力な警告が重大障害の5秒前にバッファを提供
- 運用者がクロック問題を事前に修正可能
- 明確なエラーメッセージがトラブルシューティングをガイド

---

## ノード運用者向けベストプラクティス

### 時刻同期セットアップ

**推奨設定**:
1. **NTPを有効化**: 自動同期にNetwork Time Protocolを使用
   ```bash
   # Linux（systemd-timesyncd）
   sudo timedatectl set-ntp true

   # ステータスを確認
   timedatectl status
   ```

2. **クロック精度を確認**: 定期的に時間オフセットをチェック
   ```bash
   # NTP同期ステータスをチェック
   ntpq -p

   # またはchronyで
   chronyc tracking
   ```

3. **警告を監視**: ログでBitcoin-PoCXクロックドリフト警告を監視

### マイナー向け

**アクション不要**:
- 機能は常にアクティブ
- 自動的に動作
- システム時刻を正確に保つだけ

**ベストプラクティス**:
- NTP時刻同期を使用
- クロックドリフト警告を監視
- 警告が出たらすぐに対処

**予想される動作**:
- ソロマイニング: 防御的フォージングはめったに発動しない（競争なし）
- ネットワークマイニング: クロック操作試行から保護
- 透明な動作: ほとんどのマイナーは気づかない

### トラブルシューティング

**警告: "10秒以上ずれています"**
- アクション: システム時刻同期を確認して修正
- 影響: 重大障害の5秒前のバッファ
- ツール: NTP、chrony、systemd-timesyncd

**エラー: 受信ブロックで"time-too-new"**
- 原因: クロックが15秒以上遅れている
- 影響: ブロック検証不可、ノード分離
- 修正: システム時刻を即座に同期

**エラー: フォージされたブロックを伝播できない**
- 原因: クロックが15秒以上進んでいる
- 影響: ブロックはネットワークに拒否される
- 修正: システム時刻を即座に同期

---

## 設計決定と根拠

### なぜ15秒許容範囲?

**根拠**:
- Bitcoin-PoCXの可変デッドラインタイミングは固定タイミングコンセンサスより時間的制約が少ない
- 15秒はネットワーク断片化を防ぎながら適切な保護を提供

**トレードオフ**:
- より厳しい許容範囲 = 軽微なドリフトからのネットワーク断片化増加
- より緩い許容範囲 = タイミング攻撃の機会増加
- 15秒はセキュリティと堅牢性のバランス

### なぜ10秒警告?

**理由**:
- 5秒の安全バッファを提供
- Bitcoinの10分デフォルトよりPoCに適切
- 重大障害前の事前修正を可能に

### なぜ防御的フォージング?

**対処した問題**:
- 15秒許容範囲は高速クロック優位性を可能に
- 品質ベースコンセンサスがタイミング操作で損なわれる可能性

**解決策の利点**:
- ゼロコスト防御（コンセンサス変更なし）
- 自動動作
- 攻撃インセンティブを排除
- 容量証明原則を保持

### なぜネットワーク内時刻同期なし?

**セキュリティ上の理由**:
- 最新のBitcoin Coreはピアベースの時刻調整を削除
- 認知されたネットワーク時刻へのシビル攻撃に脆弱
- PoCXは意図的にネットワーク内部の時刻ソースへの依存を回避
- システム時刻はピアコンセンサスより信頼性が高い
- 運用者はNTPまたは同等の外部時刻ソースを使用して同期すべき
- ノードは自身のドリフトを監視し、ローカル時刻が最近のブロックタイムスタンプから乖離すると警告を発する

---

## 実装参照

**コアファイル**:
- 時刻検証: `src/validation.cpp:4547-4561`
- 将来許容定数: `src/chain.h:31`
- 警告しきい値: `src/node/timeoffsets.h:27`
- 時刻オフセット監視: `src/node/timeoffsets.cpp`
- 防御的フォージング: `src/pocx/mining/scheduler.cpp`

**関連文書**:
- タイムベンディングアルゴリズム: [第3章: コンセンサスとマイニング](3-consensus-and-mining.md#タイムベンディング計算)
- ブロック検証: [第3章: ブロック検証](3-consensus-and-mining.md#ブロック検証)

---

**生成日**: 2025年10月10日
**ステータス**: 完全実装
**カバレッジ**: 時刻同期要件、クロックドリフト処理、防御的フォージング

---

[← 前へ: フォージング割り当て](4-forging-assignments.md) | [目次](index.md) | [次へ: ネットワークパラメータ →](6-network-parameters.md)
