# Bitcoin-PoCX: Bitcoin Core를 위한 에너지 효율적 합의

**버전**: 2.0 초안
**날짜**: 2025년 12월
**조직**: Proof of Capacity Consortium

---

## 초록

비트코인의 작업 증명(PoW) 합의는 견고한 보안을 제공하지만, 지속적인 실시간 해시 계산으로 인해 상당한 에너지를 소비합니다. 우리는 PoW를 용량 증명(PoC)으로 대체하는 비트코인 포크인 Bitcoin-PoCX를 제시합니다. PoC에서 채굴자는 플로팅 중 디스크에 저장된 대용량 해시 세트를 사전 계산하고, 이후 지속적인 해싱 대신 경량 조회를 수행하여 채굴합니다. 계산을 채굴 단계에서 일회성 플로팅 단계로 이전함으로써, Bitcoin-PoCX는 에너지 소비를 대폭 줄이면서 범용 하드웨어에서의 채굴을 가능하게 하여 참여 장벽을 낮추고 ASIC 지배적 PoW에 내재된 중앙화 압력을 완화합니다. 이 모든 것이 비트코인의 보안 가정과 경제적 행동을 유지하면서 이루어집니다.

우리의 구현은 몇 가지 핵심 혁신을 도입합니다:
(1) 기존 PoC 시스템의 모든 알려진 시간-메모리 트레이드오프 공격을 제거하는 강화된 플롯 형식으로, 유효 채굴력이 커밋된 스토리지 용량에 엄격히 비례하도록 보장;
(2) 데드라인 분포를 지수 분포에서 카이제곱 분포로 변환하여 평균을 변경하지 않고 블록 시간 분산을 줄이는 시간 왜곡 알고리즘;
(3) 비수탁 풀 채굴을 가능하게 하는 OP_RETURN 기반 포징 할당 메커니즘; 그리고
(4) 하드웨어가 개선됨에 따라 장기 보안 마진을 유지하기 위해 반감 일정에 맞추어 플롯 생성 난이도를 증가시키는 동적 압축 스케일링.

Bitcoin-PoCX는 최소한의 기능 플래그 수정을 통해 Bitcoin Core의 아키텍처를 유지하며, PoC 로직을 기존 합의 코드에서 격리합니다. 시스템은 120초 블록 간격을 목표로 하고 블록 보조금을 10 BTC로 조정하여 비트코인의 통화 정책을 보존합니다. 감소된 보조금은 5배 증가한 블록 빈도를 상쇄하여 장기 발행률을 비트코인의 원래 일정에 맞추고 ~2,100만 최대 공급량을 유지합니다.

---

## 1. 서론

### 1.1 동기

비트코인의 작업 증명(PoW) 합의는 10년 이상 안전함이 입증되었지만, 상당한 비용이 따릅니다: 채굴자는 지속적으로 계산 자원을 소비해야 하며, 이로 인해 높은 에너지 소비가 발생합니다. 효율성 우려를 넘어 더 넓은 동기가 있습니다: 보안을 유지하면서 참여 장벽을 낮추는 대체 합의 메커니즘을 탐구하는 것입니다. PoC는 범용 스토리지 하드웨어를 가진 거의 모든 사람이 효과적으로 채굴할 수 있게 하여, ASIC 지배적 PoW 채굴에서 볼 수 있는 중앙화 압력을 줄입니다.

용량 증명(PoC)은 지속적인 계산이 아닌 스토리지 커밋에서 채굴력을 도출하여 이를 달성합니다. 채굴자는 일회성 플로팅 단계에서 대용량의 디스크 저장 해시(플롯)를 사전 계산합니다. 그 후 채굴은 경량 조회로 구성되어, 자원 기반 합의의 보안 가정을 유지하면서 에너지 사용을 대폭 줄입니다.

### 1.2 Bitcoin Core와의 통합

Bitcoin-PoCX는 새로운 블록체인을 만드는 대신 PoC 합의를 Bitcoin Core에 통합합니다. 이 접근 방식은 Bitcoin Core의 검증된 보안, 성숙한 네트워킹 스택, 널리 채택된 도구를 활용하면서 수정을 최소화하고 기능 플래그로 처리합니다. PoC 로직은 기존 합의 코드에서 격리되어, 블록 검증, 지갑 작업, 트랜잭션 형식 등 핵심 기능이 대부분 변경되지 않도록 보장합니다.

### 1.3 설계 목표

**보안**: 비트코인과 동등한 견고함 유지; 공격에는 다수의 스토리지 용량 필요.

**효율성**: 지속적인 계산 부하를 디스크 I/O 수준으로 감소.

**접근성**: 범용 하드웨어로 채굴 가능하게 하여 진입 장벽 낮춤.

**최소 통합**: 최소한의 수정 범위로 PoC 합의 도입.

---

## 2. 배경: 용량 증명

### 2.1 역사

용량 증명(PoC)은 2014년 Burstcoin에 의해 작업 증명(PoW)의 에너지 효율적 대안으로 도입되었습니다. Burstcoin은 채굴력이 지속적인 실시간 해싱이 아닌 커밋된 스토리지에서 도출될 수 있음을 입증했습니다: 채굴자는 대용량 데이터셋("플롯")을 한 번 사전 계산한 다음 작은 고정 부분을 읽어 채굴했습니다.

초기 PoC 구현은 개념의 실행 가능성을 증명했지만, 플롯 형식과 암호화 구조가 보안에 중요하다는 것도 드러냈습니다. 여러 시간-메모리 트레이드오프가 공격자가 정직한 참여자보다 적은 스토리지로 효과적으로 채굴할 수 있게 했습니다. 이는 PoC 보안이 단순히 스토리지를 자원으로 사용하는 것이 아니라 플롯 설계에 달려 있음을 강조했습니다.

Burstcoin의 유산은 PoC를 실용적인 합의 메커니즘으로 확립하고 PoCX가 구축하는 기반을 제공했습니다.

### 2.2 핵심 개념

PoC 채굴은 디스크에 저장된 대용량 사전 계산 플롯 파일을 기반으로 합니다. 이 플롯은 "동결된 계산"을 포함합니다: 플로팅 중 비용이 큰 해싱이 한 번 수행되고, 채굴은 경량 디스크 읽기와 간단한 검증으로 구성됩니다. 핵심 요소는 다음과 같습니다:

**논스:**
플롯 데이터의 기본 단위. 각 논스는 채굴자의 주소와 논스 인덱스에서 Shabal256을 통해 생성된 4096개의 스쿱(총 256 KiB)을 포함합니다.

**스쿱:**
논스 내의 64바이트 세그먼트. 각 블록에서 네트워크는 이전 블록의 생성 서명을 기반으로 스쿱 인덱스(0-4095)를 결정론적으로 선택합니다. 논스당 이 스쿱만 읽으면 됩니다.

**생성 서명:**
이전 블록에서 도출된 256비트 값. 스쿱 선택을 위한 엔트로피를 제공하고 채굴자가 미래 스쿱 인덱스를 예측하는 것을 방지합니다.

**워프:**
4096개 논스(1 GiB)의 구조적 그룹. 워프는 압축 저항 플롯 형식에서 관련 단위입니다.

### 2.3 채굴 과정과 품질 파이프라인

PoC 채굴은 일회성 플로팅 단계와 경량 블록별 루틴으로 구성됩니다:

**일회성 설정:**
- 플롯 생성: Shabal256을 통해 논스 계산 및 디스크에 기록.

**블록별 채굴:**
- 스쿱 선택: 생성 서명에서 스쿱 인덱스 결정.
- 플롯 스캔: 채굴자 플롯의 모든 논스에서 해당 스쿱 읽기.

**품질 파이프라인:**
- 원시 품질: 각 스쿱을 생성 서명과 함께 Shabal256Lite로 해시하여 64비트 품질 값 획득 (낮을수록 좋음).
- 데드라인: 기본 목표(네트워크가 목표 블록 간격에 도달하도록 하는 난이도 조정 매개변수)를 사용하여 품질을 데드라인으로 변환: `deadline = quality / base_target`
- 왜곡된 데드라인: 시간 왜곡 변환을 적용하여 예상 블록 시간을 유지하면서 분산 감소.

**블록 포징:**
가장 짧은 (왜곡된) 데드라인을 가진 채굴자가 해당 시간이 경과하면 다음 블록을 포징합니다.

PoW와 달리, 거의 모든 계산이 플로팅 중에 발생합니다; 활성 채굴은 주로 디스크 바운드이며 매우 저전력입니다.

### 2.4 이전 시스템의 알려진 취약점

**POC1 분포 결함:**
원래 Burstcoin POC1 형식은 구조적 편향을 보였습니다: 낮은 인덱스 스쿱이 높은 인덱스 스쿱보다 즉석에서 재계산하기가 훨씬 저렴했습니다. 이는 비균일한 시간-메모리 트레이드오프를 도입하여, 공격자가 해당 스쿱에 대해 필요한 스토리지를 줄이고 모든 사전 계산된 데이터가 동등하게 비용이 든다는 가정을 깨트릴 수 있게 했습니다.

**XOR 압축 공격 (POC2):**
POC2에서 공격자는 8192개 논스 세트를 가져와 4096개 논스의 두 블록(A와 B)으로 분할할 수 있습니다. 두 블록을 모두 저장하는 대신, 공격자는 파생된 구조만 저장합니다: `A XOR transpose(B)`, 여기서 전치는 스쿱과 논스 인덱스를 교환합니다—블록 B에서 논스 N의 스쿱 S가 논스 S의 스쿱 N이 됩니다.

채굴 중 논스 N의 스쿱 S가 필요할 때, 공격자는 다음과 같이 재구성합니다:
1. 위치 (S, N)에서 저장된 XOR 값 읽기
2. 블록 A에서 논스 N을 계산하여 스쿱 S 획득
3. 블록 B에서 논스 S를 계산하여 전치된 스쿱 N 획득
4. 세 값을 XOR하여 원래 64바이트 스쿱 복구

이는 스토리지를 50% 줄이면서 조회당 두 번의 논스 계산만 필요로 합니다—완전한 사전 계산을 강제하는 데 필요한 임계값보다 훨씬 낮은 비용입니다. 공격이 가능한 이유는 행(하나의 논스, 4096 스쿱) 계산이 저렴한 반면, 열(4096 논스에 걸친 단일 스쿱) 계산은 모든 논스를 재생성해야 하기 때문입니다. 전치 구조가 이 불균형을 노출합니다.

이는 그러한 구조화된 재조합을 방지하고 기본 시간-메모리 트레이드오프를 제거하는 플롯 형식의 필요성을 보여주었습니다. 3.3절에서 PoCX가 이 약점을 어떻게 해결하는지 설명합니다.

### 2.5 PoCX로의 전환

이전 PoC 시스템의 한계는 안전하고 공정하며 분산된 스토리지 채굴이 신중하게 설계된 플롯 구조에 달려 있음을 명확히 했습니다. Bitcoin-PoCX는 강화된 플롯 형식, 개선된 데드라인 분포, 분산 풀 채굴 메커니즘으로 이러한 문제를 해결합니다—다음 섹션에서 설명합니다.

---

## 3. PoCX 플롯 형식

### 3.1 기본 논스 구성

논스는 세 가지 매개변수에서 결정론적으로 도출되는 256 KiB 데이터 구조입니다: 20바이트 주소 페이로드, 32바이트 시드, 64비트 논스 인덱스.

구성은 이러한 입력을 결합하고 Shabal256으로 해시하여 초기 해시를 생성하는 것으로 시작합니다. 이 해시는 반복적 확장 과정의 시작점 역할을 합니다: Shabal256이 반복적으로 적용되며, 각 단계는 이전에 생성된 데이터에 의존하여 전체 256 KiB 버퍼가 채워질 때까지 계속됩니다. 이 연쇄 과정은 플로팅 중 수행되는 계산 작업을 나타냅니다.

최종 확산 단계는 완성된 버퍼를 해시하고 결과를 모든 바이트에 XOR합니다. 이는 전체 버퍼가 계산되었으며 채굴자가 계산을 단축할 수 없음을 보장합니다. 그런 다음 PoC2 셔플이 적용되어 각 스쿱의 상반부와 하반부를 교환하고 모든 스쿱이 동등한 계산 노력을 요구하도록 보장합니다.

최종 논스는 각각 64바이트의 4096개 스쿱으로 구성되며 채굴에 사용되는 기본 단위를 형성합니다.

### 3.2 SIMD 정렬 플롯 레이아웃

현대 하드웨어에서 처리량을 극대화하기 위해, PoCX는 벡터화 처리를 용이하게 하도록 디스크의 논스 데이터를 구성합니다. 각 논스를 순차적으로 저장하는 대신, PoCX는 여러 연속 논스에 걸쳐 해당하는 4바이트 워드를 연속적으로 정렬합니다. 이를 통해 단일 메모리 가져오기가 모든 SIMD 레인에 데이터를 제공할 수 있어 캐시 미스를 최소화하고 스캐터-개더 오버헤드를 제거합니다.

```
전통적 레이아웃:
Nonce0: [W0][W1][W2][W3]...
Nonce1: [W0][W1][W2][W3]...
Nonce2: [W0][W1][W2][W3]...

PoCX SIMD 레이아웃:
Word0: [N0][N1][N2]...[N15]
Word1: [N0][N1][N2]...[N15]
Word2: [N0][N1][N2]...[N15]
```

이 레이아웃은 CPU와 GPU 채굴자 모두에게 이점을 제공하여, 합의 검증을 위한 간단한 스칼라 접근 패턴을 유지하면서 고처리량, 병렬화된 스쿱 평가를 가능하게 합니다. 이는 채굴이 CPU 계산이 아닌 스토리지 대역폭에 의해 제한되도록 하여 용량 증명의 저전력 특성을 유지합니다.

### 3.3 워프 구조와 XOR-전치 인코딩

워프는 PoCX의 기본 스토리지 단위로, 4096개 논스(1 GiB)로 구성됩니다. 압축되지 않은 형식인 X0은 3.1절의 구성에 의해 생성된 그대로의 기본 논스를 포함합니다.

**XOR-전치 인코딩 (X1)**

이전 PoC 시스템에 존재하는 구조적 시간-메모리 트레이드오프를 제거하기 위해, PoCX는 X0 워프 쌍에 XOR-전치 인코딩을 적용하여 강화된 채굴 형식 X1을 도출합니다.

X1 워프에서 논스 N의 스쿱 S를 구성하려면:

1. 첫 번째 X0 워프에서 논스 N의 스쿱 S 가져오기 (직접 위치)
2. 두 번째 X0 워프에서 논스 S의 스쿱 N 가져오기 (전치된 위치)
3. 두 64바이트 값을 XOR하여 X1 스쿱 획득

전치 단계는 스쿱과 논스 인덱스를 교환합니다. 행렬 용어로—행이 스쿱을 나타내고 열이 논스를 나타내는 경우—첫 번째 워프의 위치 (S, N) 요소와 두 번째 워프의 (N, S) 요소를 결합합니다.

**이것이 압축 공격 표면을 제거하는 이유**

XOR-전치는 각 스쿱을 기본 X0 데이터의 전체 행과 전체 열에 연결합니다. 따라서 단일 X1 스쿱을 복구하려면 4096개의 모든 스쿱 인덱스에 걸친 데이터 접근이 필요합니다. 누락된 데이터를 계산하려는 시도는 단일 논스가 아닌 4096개의 전체 논스를 재생성해야 하므로—POC2의 XOR 공격이 악용한 비대칭 비용 구조가 제거됩니다(2.4절).

결과적으로 전체 X1 워프를 저장하는 것이 채굴자에게 계산적으로 유일하게 실행 가능한 전략이 되어, 이전 설계에서 악용된 시간-메모리 트레이드오프를 차단합니다.

### 3.4 디스크 레이아웃

PoCX 플롯 파일은 많은 연속적인 X1 워프로 구성됩니다. 채굴 중 운영 효율성을 극대화하기 위해, 각 파일 내의 데이터는 스쿱별로 구성됩니다: 모든 워프의 모든 스쿱 0 데이터가 순차적으로 저장되고, 이어서 모든 스쿱 1 데이터, 스쿱 4095까지 계속됩니다.

이 **스쿱 순차 정렬**을 통해 채굴자는 단일 순차 디스크 접근으로 선택된 스쿱에 필요한 전체 데이터를 읽을 수 있어, 탐색 시간을 최소화하고 범용 스토리지 장치에서 처리량을 극대화합니다.

3.3절의 XOR-전치 인코딩과 결합하여, 이 레이아웃은 파일이 **구조적으로 강화**되고 **운영적으로 효율적**임을 보장합니다: 순차 스쿱 정렬은 최적의 디스크 I/O를 지원하고, SIMD 정렬 메모리 레이아웃(3.2절 참조)은 고처리량, 병렬화된 스쿱 평가를 가능하게 합니다.

### 3.5 작업 증명 스케일링 (Xn)

PoCX는 진화하는 하드웨어 성능에 적응하기 위해 Xn으로 표시되는 스케일링 레벨 개념을 통해 확장 가능한 사전 계산을 구현합니다. 기준 X1 형식은 첫 번째 XOR-전치 강화 워프 구조를 나타냅니다.

각 스케일링 레벨 Xn은 X1 대비 각 워프에 내장된 작업 증명을 기하급수적으로 증가시킵니다: 레벨 Xn에서 필요한 작업은 X1의 2^(n-1)배입니다. Xn에서 Xn+1로의 전환은 인접 워프 쌍에 XOR을 적용하는 것과 운영적으로 동등하며, 기본 플롯 크기를 변경하지 않고 더 많은 작업 증명을 점진적으로 내장합니다.

낮은 스케일링 레벨에서 생성된 기존 플롯 파일은 채굴에 여전히 사용할 수 있지만, 낮은 내장 작업 증명을 반영하여 블록 생성에 비례적으로 적게 기여합니다. 이 메커니즘은 PoCX 플롯이 시간이 지남에 따라 안전하고 유연하며 경제적으로 균형을 유지하도록 보장합니다.

### 3.6 시드 기능

시드 매개변수는 수동 조정 없이 주소당 여러 개의 중복되지 않는 플롯을 가능하게 합니다.

**문제 (POC2)**: 채굴자가 중복을 피하기 위해 플롯 파일 간에 논스 범위를 수동으로 추적해야 했습니다. 중복되는 논스는 채굴력을 증가시키지 않으면서 스토리지를 낭비합니다.

**해결책**: 각 `(address, seed)` 쌍은 독립적인 키스페이스를 정의합니다. 다른 시드를 가진 플롯은 논스 범위에 관계없이 절대 중복되지 않습니다. 채굴자는 조정 없이 자유롭게 플롯을 생성할 수 있습니다.

---

## 4. 용량 증명 합의

PoCX는 스토리지 바운드 증명 메커니즘으로 비트코인의 나카모토 합의를 확장합니다. 반복적인 해싱에 에너지를 소비하는 대신, 채굴자는 대량의 사전 계산된 데이터—플롯—를 디스크에 커밋합니다. 블록 생성 중에는 이 데이터의 작고 예측 불가능한 부분을 찾아 증명으로 변환해야 합니다. 예상 시간 윈도우 내에 최적의 증명을 제공하는 채굴자가 다음 블록을 포징할 권한을 얻습니다.

이 장에서는 PoCX가 블록 메타데이터를 구조화하고, 예측 불가능성을 도출하며, 정적 스토리지를 안전하고 저분산 합의 메커니즘으로 변환하는 방법을 설명합니다.

### 4.1 블록 구조

PoCX는 용량 기반 채굴에 필요한 추가 합의 필드로 친숙한 비트코인 스타일 블록 헤더를 유지합니다. 이 필드들은 블록을 채굴자의 저장된 플롯, 네트워크의 난이도, 각 채굴 도전을 정의하는 암호화 엔트로피에 집합적으로 바인딩합니다.

높은 수준에서 PoCX 블록은 다음을 포함합니다: 컨텍스트 검증을 단순화하기 위해 명시적으로 기록된 블록 높이; 각 블록을 이전 블록에 연결하는 신선한 엔트로피 소스인 생성 서명; 역수 형태의 네트워크 난이도를 나타내는 기본 목표(높은 값은 더 쉬운 채굴에 해당); 채굴자의 플롯, 플로팅 중 사용된 압축 레벨, 선택된 논스, 그로부터 도출된 품질을 식별하는 PoCX 증명; 그리고 블록 포징에 사용된 용량에 대한 제어를 증명하는 서명 키와 서명(또는 할당된 포징 키).

증명은 검증자가 도전을 재계산하고, 선택된 스쿱을 확인하며, 결과 품질을 확인하는 데 필요한 모든 합의 관련 정보를 내장합니다. 블록 구조를 재설계하는 대신 확장함으로써, PoCX는 근본적으로 다른 채굴 작업 소스를 가능하게 하면서도 비트코인과 개념적으로 정렬된 상태를 유지합니다.

### 4.2 생성 서명 체인

생성 서명은 안전한 용량 증명 채굴에 필요한 예측 불가능성을 제공합니다. 각 블록은 이전 블록의 서명과 서명자로부터 생성 서명을 도출하여, 채굴자가 미래의 도전을 예측하거나 유리한 플롯 영역을 사전 계산할 수 없도록 보장합니다:

`generationSignature[n] = SHA256(generationSignature[n-1] || miner_pubkey[n-1])`

이는 암호학적으로 강력한, 채굴자 의존적 엔트로피 값의 시퀀스를 생성합니다. 채굴자의 공개키는 이전 블록이 게시될 때까지 알려지지 않으므로, 어떤 참여자도 미래의 스쿱 선택을 예측할 수 없습니다. 이는 선택적 사전 계산이나 전략적 플로팅을 방지하고 모든 블록이 진정으로 신선한 채굴 작업을 도입하도록 보장합니다.

### 4.3 포징 과정

PoCX에서의 채굴은 전적으로 생성 서명에 의해 주도되는 저장된 데이터를 증명으로 변환하는 것으로 구성됩니다. 과정은 결정론적이지만, 서명의 예측 불가능성은 채굴자가 미리 준비할 수 없고 저장된 플롯에 반복적으로 접근해야 함을 보장합니다.

**도전 도출 (스쿱 선택):** 채굴자는 현재 생성 서명을 블록 높이와 함께 해시하여 0-4095 범위의 스쿱 인덱스를 획득합니다. 이 인덱스는 각 저장된 논스의 어떤 64바이트 세그먼트가 증명에 참여하는지 결정합니다. 생성 서명이 이전 블록의 서명자에 의존하므로, 스쿱 선택은 블록 게시 순간에만 알려집니다.

**증명 평가 (품질 계산):** 플롯의 각 논스에 대해, 채굴자는 선택된 스쿱을 검색하고 생성 서명과 함께 해시하여 품질을 획득합니다—크기가 채굴자의 경쟁력을 결정하는 64비트 값입니다. 낮은 품질이 더 좋은 증명에 해당합니다.

**데드라인 형성 (시간 왜곡):** 원시 데드라인은 품질에 비례하고 기본 목표에 반비례합니다. 레거시 PoC 설계에서 이 데드라인은 심하게 치우친 지수 분포를 따라, 추가 보안을 제공하지 않는 긴 꼬리 지연을 생성했습니다. PoCX는 시간 왜곡(4.4절)을 사용하여 원시 데드라인을 변환하여 분산을 줄이고 예측 가능한 블록 간격을 보장합니다. 왜곡된 데드라인이 경과하면, 채굴자는 증명을 내장하고 유효 포징 키로 서명하여 블록을 포징합니다.

### 4.4 시간 왜곡

용량 증명은 지수 분포된 데드라인을 생성합니다. 짧은 기간—일반적으로 수십 초—후에 모든 채굴자는 이미 최적의 증명을 식별했으며, 추가 대기 시간은 보안이 아닌 지연만 기여합니다.

시간 왜곡은 세제곱근 변환을 적용하여 분포를 재형성합니다:

`deadline_bended = scale × (quality / base_target)^(1/3)`

스케일 팩터는 분산을 대폭 줄이면서 예상 블록 시간(120초)을 유지합니다. 짧은 데드라인은 확장되어 블록 전파와 네트워크 안전성을 개선합니다. 긴 데드라인은 압축되어 이상치가 체인을 지연시키는 것을 방지합니다.

![블록 시간 분포](blocktime_distributions.svg)

시간 왜곡은 기본 증명의 정보 내용을 유지합니다. 채굴자 간의 경쟁력을 수정하지 않습니다; 더 부드럽고 예측 가능한 블록 간격을 생성하기 위해 대기 시간만 재배분합니다. 구현은 모든 플랫폼에서 결정론적 결과를 보장하기 위해 고정 소수점 산술(Q42 형식)과 256비트 정수를 사용합니다.

### 4.5 난이도 조정

PoCX는 기본 목표를 사용하여 블록 생성을 조절하며, 이는 역 난이도 측정입니다. 예상 블록 시간은 `quality / base_target` 비율에 비례하므로, 기본 목표를 증가시키면 블록 생성이 가속화되고 감소시키면 체인이 느려집니다.

난이도는 목표 간격과 비교한 최근 블록 간의 측정 시간을 사용하여 매 블록마다 조정됩니다. 이 빈번한 조정은 스토리지 용량이 빠르게 추가되거나 제거될 수 있기 때문에 필요합니다—더 느리게 변하는 비트코인의 해시파워와 달리.

조정은 두 가지 안내 제약을 따릅니다: **점진성**—블록당 변경이 제한됨(최대 ±20%)하여 진동이나 조작을 방지; **강화**—기본 목표가 제네시스 값을 초과할 수 없어 네트워크가 원래 보안 가정 아래로 난이도를 낮추는 것을 방지.

### 4.6 블록 유효성

PoCX에서 블록은 합의 상태와 일치하는 검증 가능한 스토리지 도출 증명을 제시할 때 유효합니다. 검증자는 스쿱 선택을 독립적으로 재계산하고, 제출된 논스 및 플롯 메타데이터에서 예상 품질을 도출하며, 시간 왜곡 변환을 적용하고, 채굴자가 선언된 시간에 블록을 포징할 자격이 있었는지 확인합니다.

구체적으로 유효한 블록은 다음을 요구합니다: 부모 블록 이후 데드라인이 경과했음; 제출된 품질이 증명에서 계산된 품질과 일치; 스케일링 레벨이 네트워크 최소값을 충족; 생성 서명이 예상 값과 일치; 기본 목표가 예상 값과 일치; 블록 서명이 유효 서명자로부터 옴; 코인베이스가 유효 서명자의 주소에 지급.

---

## 5. 포징 할당

### 5.1 동기

포징 할당을 통해 플롯 소유자는 플롯 소유권을 포기하지 않고 블록 포징 권한을 위임할 수 있습니다. 이 메커니즘은 PoCX의 보안 보장을 유지하면서 풀 채굴과 콜드 스토리지 설정을 가능하게 합니다.

풀 채굴에서 플롯 소유자는 풀에 자신을 대신하여 블록을 포징할 권한을 부여할 수 있습니다. 풀은 블록을 조립하고 보상을 분배하지만, 플롯 자체에 대한 수탁권은 얻지 못합니다. 위임은 언제든지 철회할 수 있으며, 플롯 소유자는 재플로팅 없이 풀을 떠나거나 구성을 변경할 수 있습니다.

할당은 또한 콜드 키와 핫 키 사이의 깔끔한 분리를 지원합니다. 플롯을 제어하는 개인키는 오프라인으로 유지될 수 있고, 온라인 머신에 저장된 별도의 포징 키가 블록을 생성합니다. 따라서 포징 키가 손상되더라도 소유권이 아닌 포징 권한만 손상됩니다. 플롯은 안전하게 유지되고 할당을 철회하여 보안 격차를 즉시 닫을 수 있습니다.

포징 할당은 따라서 저장된 용량에 대한 제어권이 중개자에게 이전되어서는 안 된다는 원칙을 유지하면서 운영 유연성을 제공합니다.

### 5.2 할당 프로토콜

할당은 UTXO 세트의 불필요한 성장을 피하기 위해 OP_RETURN 트랜잭션을 통해 선언됩니다. 할당 트랜잭션은 플롯 주소와 해당 플롯의 용량을 사용하여 블록을 생성할 권한이 있는 포징 주소를 지정합니다. 취소 트랜잭션은 플롯 주소만 포함합니다. 두 경우 모두 플롯 소유자는 트랜잭션의 지출 입력에 서명하여 제어를 증명합니다.

각 할당은 잘 정의된 상태 시퀀스를 통해 진행됩니다(UNASSIGNED, ASSIGNING, ASSIGNED, REVOKING, REVOKED). 할당 트랜잭션이 확인된 후 시스템은 짧은 활성화 단계에 들어갑니다. 이 지연—30 블록, 대략 1시간—은 블록 경쟁 중 안정성을 보장하고 포징 신원의 적대적인 빠른 전환을 방지합니다. 이 활성화 기간이 만료되면 할당이 활성화되고 플롯 소유자가 취소를 발행할 때까지 유지됩니다.

취소는 대략 하루에 해당하는 720 블록의 더 긴 지연 기간으로 전환됩니다. 이 기간 동안 이전 포징 주소는 활성 상태를 유지합니다. 이 더 긴 지연은 풀에 운영 안정성을 제공하고, 전략적 "할당 호핑"을 방지하며, 인프라 제공자에게 효율적으로 운영하기에 충분한 확실성을 제공합니다. 취소 지연이 만료된 후 취소가 완료되고 플롯 소유자는 새 포징 키를 지정할 수 있습니다.

할당 상태는 UTXO 세트와 병렬인 합의 레이어 구조에서 유지되며 체인 재구성의 안전한 처리를 위한 실행 취소 데이터를 지원합니다.

### 5.3 검증 규칙

모든 블록에서 검증자는 유효 서명자—블록에 서명하고 코인베이스 보상을 받아야 하는 주소—를 결정합니다. 이 서명자는 블록 높이에서의 할당 상태에만 의존합니다.

할당이 존재하지 않거나 할당이 아직 활성화 단계를 완료하지 않은 경우 플롯 소유자가 유효 서명자로 남습니다. 할당이 활성화되면 할당된 포징 주소가 서명해야 합니다. 취소 중에는 취소 지연이 만료될 때까지 포징 주소가 계속 서명합니다. 그 후에만 권한이 플롯 소유자에게 반환됩니다.

검증자는 블록 서명이 유효 서명자에 의해 생성되었는지, 코인베이스가 동일한 주소에 지급되는지, 모든 전환이 규정된 활성화 및 취소 지연을 따르는지 확인합니다. 플롯 소유자만 할당을 생성하거나 취소할 수 있습니다; 포징 키는 자신의 권한을 수정하거나 확장할 수 없습니다.

포징 할당은 따라서 신뢰 없이 유연한 위임을 도입합니다. 기본 용량의 소유권은 항상 플롯 소유자에게 암호학적으로 고정되어 있으며, 포징 권한은 운영 필요에 따라 위임, 교체 또는 철회될 수 있습니다.

---

## 6. 동적 스케일링

하드웨어가 발전함에 따라 디스크에서 사전 계산된 작업을 읽는 것 대비 플롯 계산 비용이 감소합니다. 대응책 없이는 공격자가 결국 저장된 작업을 읽는 채굴자보다 빠르게 즉석에서 증명을 생성할 수 있어 용량 증명의 보안 모델을 훼손할 수 있습니다.

의도된 보안 마진을 유지하기 위해 PoCX는 스케일링 일정을 구현합니다: 플롯에 대한 최소 필요 스케일링 레벨이 시간이 지남에 따라 증가합니다. 3.5절에서 설명한 각 스케일링 레벨 Xn은 플롯 구조 내에 기하급수적으로 더 많은 작업 증명을 내장하여, 계산이 더 저렴해져도 채굴자가 상당한 스토리지 자원을 커밋하도록 보장합니다.

일정은 네트워크의 경제적 인센티브, 특히 블록 보상 반감과 일치합니다. 블록당 보상이 감소함에 따라 최소 레벨이 점진적으로 증가하여 플로팅 노력과 채굴 잠재력 사이의 균형을 유지합니다:

| 기간 | 년차 | 반감 횟수 | 최소 스케일링 | 플롯 작업 배수 |
|------|------|----------|--------------|---------------|
| 에포크 0 | 0-4 | 0 | X1 | 2× 기준선 |
| 에포크 1 | 4-12 | 1-2 | X2 | 4× 기준선 |
| 에포크 2 | 12-28 | 3-6 | X3 | 8× 기준선 |
| 에포크 3 | 28-60 | 7-14 | X4 | 16× 기준선 |
| 에포크 4 | 60-124 | 15-30 | X5 | 32× 기준선 |
| 에포크 5 | 124+ | 31+ | X6 | 64× 기준선 |

채굴자는 선택적으로 현재 최소보다 한 레벨 높은 플롯을 준비하여 미리 계획하고 네트워크가 다음 에포크로 전환할 때 즉각적인 업그레이드를 피할 수 있습니다. 이 선택적 단계는 블록 확률 면에서 추가 이점을 제공하지 않습니다—단지 더 부드러운 운영 전환을 허용할 뿐입니다.

해당 높이의 최소 스케일링 레벨 미만의 증명을 포함하는 블록은 유효하지 않은 것으로 간주됩니다. 검증자는 합의 검증 중 증명에 선언된 스케일링 레벨을 현재 네트워크 요구사항과 비교하여 모든 참여 채굴자가 진화하는 보안 기대를 충족하도록 보장합니다.

---

## 7. 채굴 아키텍처

PoCX는 합의 핵심 작업을 자원 집약적인 채굴 작업에서 분리하여 보안과 효율성을 모두 가능하게 합니다. 노드는 블록체인을 유지하고, 블록을 검증하고, 멤풀을 관리하며, RPC 인터페이스를 노출합니다. 외부 마이너는 플롯 스토리지, 스쿱 읽기, 품질 계산, 데드라인 관리를 처리합니다. 이 분리는 합의 로직을 단순하고 감사 가능하게 유지하면서 마이너가 디스크 처리량을 최적화할 수 있게 합니다.

### 7.1 채굴 RPC 인터페이스

마이너는 최소한의 RPC 호출 세트를 통해 노드와 상호작용합니다. get_mining_info RPC는 현재 블록 높이, 생성 서명, 기본 목표, 목표 데드라인, 허용 가능한 플롯 스케일링 레벨 범위를 제공합니다. 이 정보를 사용하여 마이너는 후보 논스를 계산합니다. submit_nonce RPC를 통해 마이너는 플롯 식별자, 논스 인덱스, 스케일링 레벨, 마이너 계정을 포함한 제안된 솔루션을 제출할 수 있습니다. 노드는 제출을 평가하고 증명이 유효하면 계산된 데드라인으로 응답합니다.

### 7.2 포징 스케줄러

노드는 들어오는 제출을 추적하고 각 블록 높이에 대해 최적의 솔루션만 보유하는 포징 스케줄러를 유지합니다. 제출된 논스는 제출 플러딩이나 서비스 거부 공격에 대한 내장 보호와 함께 큐에 추가됩니다. 스케줄러는 계산된 데드라인이 만료되거나 더 우수한 솔루션이 도착할 때까지 대기한 후 블록을 조립하고, 유효 포징 키로 서명하고, 네트워크에 게시합니다.

### 7.3 방어적 포징

타이밍 공격이나 시계 조작에 대한 인센티브를 방지하기 위해 PoCX는 방어적 포징을 구현합니다. 동일한 높이에 대해 경쟁 블록이 도착하면, 스케줄러는 로컬 솔루션을 새 블록과 비교합니다. 로컬 품질이 우수하면 노드는 원래 데드라인을 기다리지 않고 즉시 포징합니다. 이는 채굴자가 단순히 로컬 시계를 조정하여 이점을 얻을 수 없도록 보장합니다; 최적의 솔루션이 항상 우세하여 공정성과 네트워크 보안을 유지합니다.

---

## 8. 보안 분석

### 8.1 위협 모델

PoCX는 상당하지만 제한된 능력을 가진 적을 모델링합니다. 공격자는 네트워크에 유효하지 않은 트랜잭션, 잘못된 형식의 블록, 조작된 증명을 범람시켜 검증 경로에 스트레스 테스트를 시도할 수 있습니다. 그들은 로컬 시계를 자유롭게 조작하고 타임스탬프 처리, 난이도 조정 역학, 재구성 규칙과 같은 합의 동작의 에지 케이스를 악용하려 시도할 수 있습니다. 적들은 또한 표적 체인 포크를 통해 역사를 다시 쓸 기회를 탐색할 것으로 예상됩니다.

모델은 단일 당사자가 총 네트워크 스토리지 용량의 과반수를 제어하지 않는다고 가정합니다. 모든 자원 기반 합의 메커니즘과 마찬가지로, 51% 용량 공격자는 체인을 일방적으로 재구성할 수 있습니다; 이 근본적인 제한은 PoCX에 특정되지 않습니다. PoCX는 또한 공격자가 정직한 채굴자가 디스크에서 읽는 것보다 빠르게 플롯 데이터를 계산할 수 없다고 가정합니다. 스케일링 일정(6절)은 하드웨어가 개선됨에 따라 보안에 필요한 계산 격차가 시간이 지남에 따라 증가하도록 보장합니다.

다음 섹션에서는 각 주요 공격 클래스를 자세히 검토하고 PoCX에 내장된 대응책을 설명합니다.

### 8.2 용량 공격

PoW와 마찬가지로, 다수 용량을 가진 공격자는 역사를 다시 쓸 수 있습니다(51% 공격). 이를 달성하려면 정직한 네트워크보다 더 큰 물리적 스토리지 풋프린트를 획득해야 합니다—비용이 많이 들고 물류적으로 요구되는 작업입니다. 하드웨어가 획득되면 운영 비용은 낮지만, 초기 투자는 정직하게 행동할 강한 경제적 인센티브를 만듭니다: 체인을 훼손하면 공격자 자신의 자산 기반 가치가 손상됩니다.

PoC는 또한 PoS와 관련된 아무것도 걸려 있지 않음 문제를 피합니다. 채굴자가 여러 경쟁 포크에 대해 플롯을 스캔할 수 있지만, 각 스캔은 실제 시간—일반적으로 체인당 수십 초 정도—을 소비합니다. 120초 블록 간격에서 이는 본질적으로 다중 포크 채굴을 제한하며, 많은 포크를 동시에 채굴하려는 시도는 모든 포크에서 성능을 저하시킵니다. 따라서 포크 채굴은 무비용이 아닙니다; I/O 처리량에 의해 근본적으로 제한됩니다.

미래 하드웨어가 거의 즉각적인 플롯 스캔(예: 고속 SSD)을 허용하더라도, 공격자는 여전히 네트워크 용량의 과반수를 제어하기 위해 상당한 물리적 자원 요구사항에 직면하여 51% 스타일 공격을 비용이 많이 들고 물류적으로 어렵게 만듭니다.

마지막으로 용량 공격은 해시파워 공격보다 대여하기가 훨씬 어렵습니다. GPU 컴퓨팅은 수요에 따라 획득하여 즉시 모든 PoW 체인으로 리디렉션할 수 있습니다. 반면 PoC는 물리적 하드웨어, 시간 집약적인 플로팅, 지속적인 I/O 작업이 필요합니다. 이러한 제약은 단기적이고 기회주의적인 공격을 훨씬 덜 실행 가능하게 만듭니다.

### 8.3 타이밍 공격

타이밍은 작업 증명보다 용량 증명에서 더 중요한 역할을 합니다. PoW에서 타임스탬프는 주로 난이도 조정에 영향을 미칩니다; PoC에서는 채굴자의 데드라인이 경과했는지, 따라서 블록이 포징할 자격이 있는지를 결정합니다. 데드라인은 부모 블록의 타임스탬프를 기준으로 측정되지만, 노드의 로컬 시계는 들어오는 블록이 너무 먼 미래인지 판단하는 데 사용됩니다. 이러한 이유로 PoCX는 엄격한 타임스탬프 허용을 적용합니다: 블록은 노드의 로컬 시계에서 15초 이상 벗어날 수 없습니다(비트코인의 2시간 윈도우와 비교). 이 제한은 양방향으로 작동합니다—너무 먼 미래의 블록은 거부되고, 느린 시계를 가진 노드는 유효한 들어오는 블록을 잘못 거부할 수 있습니다.

따라서 노드는 NTP 또는 동등한 시간 소스를 사용하여 시계를 동기화해야 합니다. PoCX는 공격자가 인지된 네트워크 시간을 조작하는 것을 방지하기 위해 의도적으로 네트워크 내부 시간 소스에 의존하지 않습니다. 노드는 자체 오차를 모니터링하고 로컬 시계가 최근 블록 타임스탬프에서 벗어나기 시작하면 경고를 발생시킵니다.

시계 가속—더 일찍 포징하기 위해 빠른 로컬 시계를 실행하는 것—은 한계적인 이점만 제공합니다. 허용된 허용 범위 내에서 방어적 포징(7.3절)은 더 나은 솔루션을 가진 채굴자가 열등한 조기 블록을 보면 즉시 게시하도록 보장합니다. 빠른 시계는 채굴자가 이미 승리하는 솔루션을 몇 초 더 일찍 게시하는 데만 도움이 됩니다; 열등한 증명을 승리하는 것으로 변환할 수 없습니다.

타임스탬프를 통해 난이도를 조작하려는 시도는 블록당 ±20% 조정 상한과 24블록 롤링 윈도우에 의해 제한되어, 채굴자가 단기 타이밍 게임을 통해 난이도에 의미 있게 영향을 미치는 것을 방지합니다.

### 8.4 시간-메모리 트레이드오프 공격

시간-메모리 트레이드오프는 수요에 따라 플롯 일부를 재계산하여 스토리지 요구사항을 줄이려 시도합니다. 이전 용량 증명 시스템은 그러한 공격에 취약했으며, 가장 주목할 만한 것은 POC1 스쿱 불균형 결함과 POC2 XOR-전치 압축 공격입니다(2.4절). 둘 다 플롯 데이터의 특정 부분을 재생성하는 것이 얼마나 비용이 드는지의 비대칭성을 악용하여, 적들이 작은 계산 패널티만 지불하면서 스토리지를 줄일 수 있게 했습니다. 또한 PoC2에 대한 대안 플롯 형식도 유사한 TMTO 약점을 가지고 있습니다; 대표적인 예가 플롯 형식이 4배 이상 임의로 줄어들 수 있는 Chia입니다.

PoCX는 논스 구성과 워프 형식을 통해 이러한 공격 표면을 완전히 제거합니다. 각 논스 내에서 최종 확산 단계는 완전히 계산된 버퍼를 해시하고 결과를 모든 바이트에 XOR하여, 버퍼의 모든 부분이 다른 모든 부분에 의존하고 단축될 수 없도록 보장합니다. 그 후 PoC2 셔플은 각 스쿱의 상반부와 하반부를 교환하여 모든 스쿱을 복구하는 계산 비용을 균등화합니다.

PoCX는 강화된 X1 형식을 도출하여 POC2 XOR-전치 압축 공격을 추가로 제거합니다. X1에서 각 스쿱은 쌍을 이룬 워프에 걸쳐 직접 위치와 전치된 위치의 XOR입니다; 이는 모든 스쿱을 기본 X0 데이터의 전체 행과 전체 열과 연결하여, 재구성에 수천 개의 전체 논스가 필요하게 하고 비대칭 시간-메모리 트레이드오프를 완전히 제거합니다.

결과적으로 전체 플롯을 저장하는 것이 채굴자에게 계산적으로 유일하게 실행 가능한 전략입니다. 부분 플로팅, 선택적 재생성, 구조화된 압축, 하이브리드 계산-스토리지 접근 등 알려진 단축은 의미 있는 이점을 제공하지 않습니다. PoCX는 채굴이 엄격히 스토리지 바운드로 유지되고 용량이 실제 물리적 커밋을 반영하도록 보장합니다.

### 8.5 할당 공격

PoCX는 모든 플롯-포저 할당을 관리하기 위해 결정론적 상태 머신을 사용합니다. 각 할당은 잘 정의된 상태—UNASSIGNED -> ASSIGNING -> ASSIGNED -> REVOKING -> REVOKED—를 통해 진행되며, 강제된 활성화 및 취소 지연이 있습니다. 이는 채굴자가 시스템을 속이거나 포징 권한을 빠르게 전환하기 위해 즉각적으로 할당을 변경할 수 없도록 보장합니다.

모든 전환은 암호화 증명—구체적으로, 입력 UTXO에 대해 검증 가능한 플롯 소유자의 서명—을 요구하므로, 네트워크는 각 할당의 적법성을 신뢰할 수 있습니다. 상태 머신을 우회하거나 할당을 위조하려는 시도는 합의 검증 중에 자동으로 거부됩니다. 재생 공격도 마찬가지로 표준 비트코인 스타일 트랜잭션 재생 보호에 의해 방지되어, 모든 할당 작업이 유효하고 미지출된 입력에 고유하게 연결되도록 보장합니다.

상태 머신 거버넌스, 강제된 지연, 암호화 증명의 조합은 할당 기반 부정행위를 실질적으로 불가능하게 만듭니다: 채굴자는 할당을 탈취하거나, 블록 경쟁 중 빠른 재할당을 수행하거나, 취소 일정을 우회할 수 없습니다.

### 8.6 서명 보안

PoCX에서 블록 서명은 증명과 유효 포징 키 사이의 중요한 연결 역할을 하여, 승인된 채굴자만 유효한 블록을 생성할 수 있도록 보장합니다.

가변성 공격을 방지하기 위해 서명은 블록 해시 계산에서 제외됩니다. 이는 검증을 훼손하거나 블록 교체 공격을 허용할 수 있는 가변성 서명의 위험을 제거합니다.

서비스 거부 벡터를 완화하기 위해 서명 및 공개키 크기는 고정됩니다—컴팩트 서명 65바이트, 압축 공개키 33바이트—공격자가 블록을 부풀려 자원 고갈이나 네트워크 전파 지연을 트리거하는 것을 방지합니다.

---

## 9. 구현

PoCX는 Bitcoin Core에 대한 모듈식 확장으로 구현되며, 모든 관련 코드가 전용 하위 디렉토리에 포함되고 기능 플래그를 통해 활성화됩니다. 이 설계는 원래 코드의 무결성을 보존하여 PoCX를 깔끔하게 활성화하거나 비활성화할 수 있으며, 테스트, 감사, 업스트림 변경 사항과의 동기화를 단순화합니다.

통합은 용량 증명을 지원하는 데 필요한 본질적인 지점에만 접촉합니다. 블록 헤더는 PoCX 전용 필드를 포함하도록 확장되었으며, 합의 검증은 전통적인 비트코인 검사와 함께 스토리지 기반 증명을 처리하도록 조정되었습니다. 데드라인, 스케줄링, 마이너 제출을 관리하는 포징 시스템은 PoCX 모듈에 완전히 포함되어 있으며, RPC 확장은 채굴 및 할당 기능을 외부 클라이언트에 노출합니다. 사용자를 위해 지갑 인터페이스는 OP_RETURN 트랜잭션을 통해 할당을 관리하도록 향상되어 새 합의 기능과의 원활한 상호작용을 가능하게 합니다.

모든 합의 핵심 작업은 외부 의존성 없이 결정론적 C++로 구현되어 크로스 플랫폼 일관성을 보장합니다. Shabal256은 해싱에 사용되며, 시간 왜곡 및 품질 계산은 고정 소수점 산술과 256비트 연산에 의존합니다. 서명 검증과 같은 암호화 작업은 Bitcoin Core의 기존 secp256k1 라이브러리를 활용합니다.

이러한 방식으로 PoCX 기능을 격리함으로써, 구현은 감사 가능하고 유지 관리 가능하며 진행 중인 Bitcoin Core 개발과 완전히 호환되어, 근본적으로 새로운 스토리지 바운드 합의 메커니즘이 성숙한 작업 증명 코드베이스의 무결성이나 사용성을 방해하지 않고 공존할 수 있음을 보여줍니다.

---

## 10. 네트워크 매개변수

PoCX는 비트코인의 네트워크 인프라를 기반으로 하고 체인 매개변수 프레임워크를 재사용합니다. 용량 기반 채굴, 블록 간격, 할당 처리, 플롯 스케일링을 지원하기 위해 여러 매개변수가 확장되거나 재정의되었습니다. 여기에는 블록 시간 목표, 초기 보조금, 반감 일정, 할당 활성화 및 취소 지연, 매직 바이트, 포트, Bech32 접두사와 같은 네트워크 식별자가 포함됩니다. 테스트넷과 regtest 환경은 빠른 반복과 저용량 테스트를 가능하게 하기 위해 이러한 매개변수를 추가로 조정합니다.

아래 표는 결과 메인넷, 테스트넷, regtest 설정을 요약하여 PoCX가 스토리지 바운드 합의 모델에 비트코인의 핵심 매개변수를 어떻게 적응시키는지 강조합니다.

### 10.1 메인넷

| 매개변수 | 값 |
|----------|-----|
| 매직 바이트 | `0xa7 0x3c 0x91 0x5e` |
| 기본 포트 | 8888 |
| Bech32 HRP | `pocx` |
| 블록 시간 목표 | 120초 |
| 초기 보조금 | 10 BTC |
| 반감 간격 | 1050000 블록 (~4년) |
| 총 공급량 | ~2,100만 BTC |
| 할당 활성화 | 30 블록 |
| 할당 취소 | 720 블록 |
| 롤링 윈도우 | 24 블록 |

### 10.2 테스트넷

| 매개변수 | 값 |
|----------|-----|
| 매직 바이트 | `0x6d 0xf2 0x48 0xb3` |
| 기본 포트 | 18888 |
| Bech32 HRP | `tpocx` |
| 블록 시간 목표 | 120초 |
| 기타 매개변수 | 메인넷과 동일 |

### 10.3 Regtest

| 매개변수 | 값 |
|----------|-----|
| 매직 바이트 | `0xfa 0xbf 0xb5 0xda` |
| 기본 포트 | 18444 |
| Bech32 HRP | `rpocx` |
| 블록 시간 목표 | 1초 |
| 반감 간격 | 500 블록 |
| 할당 활성화 | 4 블록 |
| 할당 취소 | 8 블록 |
| 저용량 모드 | 활성화 (~4 MB 플롯) |

---

## 11. 관련 연구

수년에 걸쳐 여러 블록체인 및 합의 프로젝트가 스토리지 기반 또는 하이브리드 채굴 모델을 탐구했습니다. PoCX는 이 계보를 기반으로 하면서 보안, 효율성, 호환성에서 개선을 도입합니다.

**Burstcoin / Signum.** Burstcoin은 2014년에 플롯, 논스, 스쿱, 데드라인 기반 채굴과 같은 핵심 개념을 정의하며 최초의 실용적인 용량 증명(PoC) 시스템을 도입했습니다. 그 후속인 Signum(이전의 Burstcoin)은 생태계를 확장하고 결국 유효 용량에 영향을 미치기 위해 스토리지 커밋과 선택적 스테이킹을 결합하는 Proof-of-Commitment(PoC+)로 발전했습니다. PoCX는 이러한 프로젝트로부터 스토리지 기반 채굴 기반을 상속하지만, 강화된 플롯 형식(XOR-전치 인코딩), 동적 플롯 작업 스케일링, 데드라인 스무딩("시간 왜곡"), 유연한 할당 시스템으로 크게 분기하며—이 모든 것이 독립적인 네트워크 포크를 유지하는 대신 Bitcoin Core 코드베이스에 고정됩니다.

**Chia.** Chia는 검증 가능한 지연 함수(VDF)를 통해 시간 구성요소와 디스크 기반 스토리지 증명을 결합하는 Proof of Space and Time을 구현합니다. 그 설계는 클래식 PoC와 구별되는 증명 재사용 및 신선한 도전 생성에 대한 특정 우려를 해결합니다. PoCX는 그 시간 고정 증명 모델을 채택하지 않습니다; 대신 UTXO 경제학 및 비트코인 파생 도구와의 장기 호환성을 위해 최적화된 예측 가능한 간격의 스토리지 바운드 합의를 유지합니다.

**Spacemesh.** Spacemesh는 DAG 기반(메시) 네트워크 토폴로지를 사용하는 Proof-of-Space-Time(PoST) 방식을 제안합니다. 이 모델에서 참여자는 단일 사전 계산 데이터셋에 의존하는 대신 할당된 스토리지가 시간이 지남에 따라 손상되지 않았음을 주기적으로 증명해야 합니다. 반면 PoCX는 블록 시간에만 스토리지 커밋을 검증합니다—효율성과 분산화를 유지하면서 지속적인 스토리지 증명의 오버헤드를 피하며 강화된 플롯 형식과 엄격한 증명 검증을 사용합니다.

---

## 12. 결론

Bitcoin-PoCX는 보안 속성과 경제 모델을 보존하면서 에너지 효율적인 합의를 Bitcoin Core에 통합할 수 있음을 보여줍니다. 주요 기여에는 XOR-전치 인코딩(공격자가 조회당 4096개 논스를 계산하도록 강제하여 압축 공격 제거), 시간 왜곡 알고리즘(분포 변환으로 블록 시간 분산 감소), 포징 할당 시스템(OP_RETURN 기반 위임으로 비수탁 풀 채굴 가능), 동적 스케일링(반감과 정렬되어 보안 마진 유지), 그리고 최소 통합(전용 디렉토리에 격리된 기능 플래그 코드)이 포함됩니다.

시스템은 현재 테스트넷 단계에 있습니다. 채굴력은 해시율이 아닌 스토리지 용량에서 파생되어, 비트코인의 검증된 경제 모델을 유지하면서 에너지 소비를 수십 배 줄입니다.

---

## 참고문헌

Bitcoin Core. *Bitcoin Core Repository.* https://github.com/bitcoin/bitcoin

Burstcoin. *Proof of Capacity Technical Documentation.* 2014.

NIST. *SHA-3 Competition: Shabal.* 2008.

Cohen, B., Pietrzak, K. *The Chia Network Blockchain.* 2019.

Spacemesh. *Spacemesh Protocol Documentation.* 2021.

PoC Consortium. *PoCX Framework.* https://github.com/PoC-Consortium/pocx

PoC Consortium. *Bitcoin-PoCX Integration.* https://github.com/PoC-Consortium/bitcoin-pocx

---

**라이선스**: MIT
**조직**: Proof of Capacity Consortium
**상태**: 테스트넷 단계
