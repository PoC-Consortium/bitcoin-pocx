[<- 이전: 포징 할당](4-forging-assignments.md) | [목차](index.md) | [다음: 네트워크 매개변수 ->](6-network-parameters.md)

---

# 5장: 시간 동기화 및 보안

## 개요

PoCX 합의는 네트워크 전체에 걸쳐 정확한 시간 동기화를 요구합니다. 이 장에서는 시간 관련 보안 메커니즘, 시계 오차 허용 및 방어적 포징 동작을 문서화합니다.

**핵심 메커니즘**:
- 블록 타임스탬프에 대한 15초 미래 허용
- 10초 시계 오차 경고 시스템
- 방어적 포징 (시계 조작 방지)
- 시간 왜곡 알고리즘 통합

---

## 목차

1. [시간 동기화 요구사항](#시간-동기화-요구사항)
2. [시계 오차 감지 및 경고](#시계-오차-감지-및-경고)
3. [방어적 포징 메커니즘](#방어적-포징-메커니즘)
4. [보안 위협 분석](#보안-위협-분석)
5. [노드 운영자를 위한 모범 사례](#노드-운영자를-위한-모범-사례)

---

## 시간 동기화 요구사항

### 상수 및 매개변수

**Bitcoin-PoCX 구성:**
```cpp
// src/chain.h:31
static constexpr int64_t MAX_FUTURE_BLOCK_TIME = 15;  // 15초

// src/node/timeoffsets.h:27
static constexpr std::chrono::seconds WARN_THRESHOLD{10};  // 10초
```

### 검증 검사

**블록 타임스탬프 검증** (`src/validation.cpp:4547-4561`):
```cpp
// 1. 단조 증가 검사: 타임스탬프 >= 이전 블록 타임스탬프
if (block.nTime < pindexPrev->nTime) {
    return state.Invalid("time-too-old");
}

// 2. 미래 검사: 타임스탬프 <= 현재 + 15초
if (block.Time() > NodeClock::now() + std::chrono::seconds{MAX_FUTURE_BLOCK_TIME}) {
    return state.Invalid("time-too-new");
}

// 3. 데드라인 검사: 경과 시간 >= 데드라인
uint32_t elapsed_time = block.nTime - pindexPrev->nTime;
if (result.deadline > elapsed_time) {
    return state.Invalid("bad-pocx-timing");
}
```

### 시계 오차 영향 표

| 시계 오프셋 | 동기화 가능? | 채굴 가능? | 검증 상태 | 경쟁력 효과 |
|-------------|-------------|-----------|-----------|-------------|
| -30초 느림 | 아니오 - 미래 검사 실패 | 해당 없음 | **죽은 노드** | 참여 불가 |
| -14초 느림 | 예 | 예 | 늦은 포징, 검증 통과 | 경쟁에서 패배 |
| 0초 정확 | 예 | 예 | 최적 | 최적 |
| +14초 빠름 | 예 | 예 | 이른 포징, 검증 통과 | 경쟁에서 승리 |
| +16초 빠름 | 예 | 아니오 - 미래 검사 실패 | 블록 전파 불가 | 동기화 가능, 채굴 불가 |

**핵심 통찰**: 15초 윈도우는 참여에 대해 대칭적(+-14.9초)이지만, 빠른 시계는 허용 범위 내에서 불공정한 경쟁 이점을 제공합니다.

### 시간 왜곡 통합

시간 왜곡 알고리즘([3장](3-consensus-and-mining.md#시간-왜곡-계산)에서 상세히 설명)은 세제곱근을 사용하여 원시 데드라인을 변환합니다:

```
time_bended_deadline = scale × (deadline_seconds)^(1/3)
```

**시계 오차와의 상호작용**:
- 더 나은 솔루션이 더 빨리 포징됨 (세제곱근이 품질 차이를 증폭)
- 시계 오차가 네트워크 대비 포징 시간에 영향
- 방어적 포징이 타이밍 분산에도 불구하고 품질 기반 경쟁 보장

---

## 시계 오차 감지 및 경고

### 경고 시스템

Bitcoin-PoCX는 로컬 노드와 네트워크 피어 간의 시간 오프셋을 모니터링합니다.

**경고 메시지** (오차가 10초를 초과할 때):
> "컴퓨터의 날짜와 시간이 네트워크와 10초 이상 동기화되지 않은 것으로 보입니다. 이로 인해 PoCX 합의 실패가 발생할 수 있습니다. 시스템 시계를 확인하세요."

**구현**: `src/node/timeoffsets.cpp`

### 설계 근거

**왜 10초인가?**
- 15초 허용 한계 전에 5초 안전 버퍼 제공
- Bitcoin Core 기본값(10분)보다 더 엄격함
- PoC 타이밍 요구사항에 적합

**예방적 접근**:
- 치명적 실패 전 조기 경고
- 운영자가 사전에 문제 해결 가능
- 시간 관련 실패로 인한 네트워크 분열 감소

---

## 방어적 포징 메커니즘

### 정의

방어적 포징은 블록 생성에서 타이밍 기반 이점을 제거하는 Bitcoin-PoCX의 표준 마이너 동작입니다. 마이너가 동일한 높이에서 경쟁 블록을 수신하면, 자동으로 더 나은 솔루션을 가지고 있는지 확인합니다. 그렇다면 즉시 블록을 포징하여 시계 조작 기반 경쟁이 아닌 품질 기반 경쟁을 보장합니다.

### 문제

PoCX 합의는 최대 15초 미래의 타임스탬프를 가진 블록을 허용합니다. 이 허용은 전역 네트워크 동기화에 필요합니다. 그러나 이는 시계 조작 기회를 만듭니다:

**방어적 포징 없이:**
- 마이너 A: 정확한 시간, 품질 800 (더 좋음), 적절한 데드라인 대기
- 마이너 B: 빠른 시계 (+14초), 품질 1000 (더 나쁨), 14초 일찍 포징
- 결과: 마이너 B가 열등한 용량 증명 작업에도 불구하고 경쟁에서 승리

**문제점:** 시계 조작이 더 나쁜 품질에서도 이점을 제공하여 용량 증명 원칙을 훼손합니다.

### 해결책: 이중 방어

#### 레이어 1: 시계 오차 경고 (예방적)

Bitcoin-PoCX는 노드와 네트워크 피어 간의 시간 오프셋을 모니터링합니다. 시계가 네트워크 합의에서 10초 이상 벗어나면 문제가 발생하기 전에 시계 문제를 수정하라는 경고를 받습니다.

#### 레이어 2: 방어적 포징 (반응적)

다른 마이너가 채굴 중인 동일한 높이에서 블록을 게시할 때:

1. **감지**: 노드가 동일 높이 경쟁 식별
2. **검증**: 경쟁 블록의 품질을 추출하고 검증
3. **비교**: 품질이 더 좋은지 확인
4. **대응**: 더 좋으면 즉시 블록 포징

**결과:** 네트워크가 두 블록을 모두 수신하고 표준 포크 해결을 통해 더 나은 품질을 선택합니다.

### 작동 방식

#### 시나리오: 동일 높이 경쟁

```
시간 150초: 마이너 B (시계 +10초)가 품질 1000으로 포징
           -> 블록 타임스탬프는 160초 (10초 미래)

시간 150초: 노드가 마이너 B의 블록 수신
           -> 감지: 동일 높이, 품질 1000
           -> 보유 중: 품질 800 (더 좋음!)
           -> 조치: 정확한 타임스탬프(150초)로 즉시 포징

시간 152초: 네트워크가 두 블록 모두 검증
           -> 둘 다 유효 (15초 허용 내)
           -> 품질 800 승리 (낮을수록 좋음)
           -> 블록이 체인 팁이 됨
```

#### 시나리오: 진정한 재구성

```
채굴 높이 100, 경쟁자가 블록 99 게시
-> 동일 높이 경쟁 아님
-> 방어적 포징 트리거되지 않음
-> 정상 재구성 처리 진행
```

### 이점

**시계 조작에 대한 제로 인센티브**
- 빠른 시계는 이미 최고 품질을 가진 경우에만 도움됨
- 시계 조작이 경제적으로 무의미해짐

**품질 기반 경쟁 강제**
- 채굴자가 실제 용량 증명 작업으로 경쟁하도록 강제
- PoCX 합의 무결성 보존

**네트워크 보안**
- 타이밍 기반 게임 전략에 저항
- 합의 변경 필요 없음 - 순수 마이너 동작

**완전 자동화**
- 구성 필요 없음
- 필요할 때만 트리거
- 모든 Bitcoin-PoCX 노드의 표준 동작

### 트레이드오프

**최소한의 고아 블록 증가**
- 의도적 - 공격 블록이 고아됨
- 실제 시계 조작 시도 시에만 발생
- 품질 기반 포크 해결의 자연스러운 결과

**짧은 네트워크 경쟁**
- 네트워크가 잠시 두 경쟁 블록을 봄
- 표준 검증을 통해 초 단위로 해결
- Bitcoin의 동시 채굴과 동일한 동작

### 기술 세부사항

**성능 영향:** 무시할 수 있음
- 동일 높이 경쟁 시에만 트리거
- 메모리 내 데이터 사용 (디스크 I/O 없음)
- 검증이 밀리초 내에 완료

**리소스 사용:** 최소
- ~20줄의 핵심 로직
- 기존 검증 인프라 재사용
- 단일 잠금 획득

**호환성:** 완전함
- 합의 규칙 변경 없음
- 모든 Bitcoin Core 기능과 작동
- 디버그 로그를 통한 선택적 모니터링

**상태**: 모든 Bitcoin-PoCX 릴리스에서 활성화
**최초 도입**: 2025-10-10

---

## 보안 위협 분석

### 빠른 시계 공격 (방어적 포징으로 완화)

**공격 벡터**:
**+14초 앞선** 시계를 가진 마이너는:
1. 블록을 정상적으로 수신 (그들에게는 오래된 것으로 보임)
2. 데드라인이 지나면 즉시 블록 포징
3. 네트워크에 14초 "이른" 것처럼 보이는 블록 브로드캐스트
4. **블록 수락됨** (15초 허용 내)
5. 정직한 마이너와의 **경쟁에서 승리**

**방어적 포징 없이 영향**:
이점이 14.9초로 제한됨 (상당한 PoC 작업을 건너뛰기에 충분하지 않음), 그러나 블록 경쟁에서 일관된 우위 제공.

**완화 (방어적 포징)**:
- 정직한 마이너가 동일 높이 경쟁 감지
- 품질 값 비교
- 품질이 더 좋으면 즉시 포징
- **결과**: 빠른 시계는 이미 최고 품질을 가진 경우에만 도움됨
- **인센티브**: 제로 - 시계 조작이 경제적으로 무의미해짐

### 느린 시계 실패 (치명적)

**실패 모드**:
**15초 이상 뒤처진** 노드는 치명적입니다:
- 들어오는 블록 검증 불가 (미래 검사 실패)
- 네트워크에서 격리됨
- 채굴이나 동기화 불가

**완화**:
- 10초 오차에서 강력한 경고가 치명적 실패 전 5초 버퍼 제공
- 운영자가 사전에 시계 문제 수정 가능
- 명확한 오류 메시지로 문제 해결 안내

---

## 노드 운영자를 위한 모범 사례

### 시간 동기화 설정

**권장 구성**:
1. **NTP 활성화**: 자동 동기화를 위해 네트워크 시간 프로토콜 사용
   ```bash
   # Linux (systemd-timesyncd)
   sudo timedatectl set-ntp true

   # 상태 확인
   timedatectl status
   ```

2. **시계 정확도 검증**: 시간 오프셋 정기적 확인
   ```bash
   # NTP 동기화 상태 확인
   ntpq -p

   # 또는 chrony 사용
   chronyc tracking
   ```

3. **경고 모니터링**: 로그에서 Bitcoin-PoCX 시계 오차 경고 확인

### 채굴자를 위한 안내

**조치 필요 없음**:
- 기능이 항상 활성화
- 자동으로 작동
- 시스템 시계만 정확하게 유지

**모범 사례**:
- NTP 시간 동기화 사용
- 시계 오차 경고 모니터링
- 경고가 나타나면 즉시 해결

**예상 동작**:
- 솔로 채굴: 방어적 포징이 거의 트리거되지 않음 (경쟁 없음)
- 네트워크 채굴: 시계 조작 시도로부터 보호
- 투명한 운영: 대부분의 채굴자가 인식하지 못함

### 문제 해결

**경고: "10초 동기화되지 않음"**
- 조치: 시스템 시계 동기화 확인 및 수정
- 영향: 치명적 실패 전 5초 버퍼
- 도구: NTP, chrony, systemd-timesyncd

**오류: 들어오는 블록에서 "time-too-new"**
- 원인: 시계가 15초 이상 느림
- 영향: 블록 검증 불가, 노드 격리됨
- 수정: 즉시 시스템 시계 동기화

**오류: 포징된 블록 전파 불가**
- 원인: 시계가 15초 이상 빠름
- 영향: 네트워크가 블록 거부
- 수정: 즉시 시스템 시계 동기화

---

## 설계 결정 및 근거

### 왜 15초 허용인가?

**근거**:
- Bitcoin-PoCX의 가변 데드라인 타이밍이 고정 타이밍 합의보다 시간에 덜 민감함
- 15초가 네트워크 분열을 방지하면서 적절한 보호 제공

**트레이드오프**:
- 더 엄격한 허용 = 사소한 오차로 인한 더 많은 네트워크 분열
- 더 느슨한 허용 = 타이밍 공격 기회 증가
- 15초가 보안과 견고성 사이의 균형

### 왜 10초 경고인가?

**근거**:
- 5초 안전 버퍼 제공
- Bitcoin의 10분 기본값보다 PoC에 더 적합
- 치명적 실패 전 사전 수정 허용

### 왜 방어적 포징인가?

**해결된 문제**:
- 15초 허용이 빠른 시계 이점 가능하게 함
- 품질 기반 합의가 타이밍 조작에 의해 훼손될 수 있음

**해결책 이점**:
- 제로 비용 방어 (합의 변경 없음)
- 자동 운영
- 공격 인센티브 제거
- 용량 증명 원칙 보존

### 왜 네트워크 내부 시간 동기화가 없는가?

**보안 근거**:
- 현대 Bitcoin Core가 피어 기반 시간 조정 제거함
- 인지된 네트워크 시간에 대한 시빌 공격에 취약
- PoCX가 의도적으로 네트워크 내부 시간 소스에 의존하지 않음
- 시스템 시계가 피어 합의보다 더 신뢰할 수 있음
- 운영자가 NTP 또는 동등한 외부 시간 소스를 사용하여 동기화해야 함
- 노드가 자체 오차를 모니터링하고 로컬 시계가 최근 블록 타임스탬프에서 벗어나면 경고 발생

---

## 구현 참조

**핵심 파일**:
- 시간 검증: `src/validation.cpp:4547-4561`
- 미래 허용 상수: `src/chain.h:31`
- 경고 임계값: `src/node/timeoffsets.h:27`
- 시간 오프셋 모니터링: `src/node/timeoffsets.cpp`
- 방어적 포징: `src/pocx/mining/scheduler.cpp`

**관련 문서**:
- 시간 왜곡 알고리즘: [3장: 합의 및 채굴](3-consensus-and-mining.md#시간-왜곡-계산)
- 블록 검증: [3장: 블록 검증](3-consensus-and-mining.md#블록-검증)

---

**생성일**: 2025-10-10
**상태**: 완전히 구현됨
**범위**: 시간 동기화 요구사항, 시계 오차 처리, 방어적 포징

---

[<- 이전: 포징 할당](4-forging-assignments.md) | [목차](index.md) | [다음: 네트워크 매개변수 ->](6-network-parameters.md)
