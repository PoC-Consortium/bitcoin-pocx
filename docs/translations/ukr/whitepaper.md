# Bitcoin-PoCX: Енергоефективний консенсус для Bitcoin Core

**Версія**: 2.0 Чернетка
**Дата**: Грудень 2025
**Організація**: Proof of Capacity Consortium

---

## Анотація

Консенсус Proof-of-Work (PoW) Bitcoin забезпечує надійну безпеку, але споживає значну енергію через безперервне обчислення хешів у реальному часі. Ми представляємо Bitcoin-PoCX — форк Bitcoin, що замінює PoW на Proof of Capacity (PoC), де майнери попередньо обчислюють та зберігають великі набори дискових хешів під час побудови плотів, а потім майнять, виконуючи легкі пошуки замість постійного хешування. Переносячи обчислення з фази майнінгу на одноразову фазу побудови плотів, Bitcoin-PoCX радикально знижує енергоспоживання, водночас дозволяючи майнінг на масовому обладнанні, знижуючи бар'єр для участі та пом'якшуючи тиск централізації, властивий PoW, домінованому ASIC, — все це зберігаючи припущення безпеки та економічну поведінку Bitcoin.

Наша реалізація вводить кілька ключових інновацій:
(1) Загартований формат плотів, що усуває всі відомі атаки компромісу часу та пам'яті в існуючих системах PoC, забезпечуючи, що ефективна потужність майнінгу залишається строго пропорційною закріпленій ємності сховища;
(2) Алгоритм Time-Bending, що трансформує розподіл дедлайнів з експоненційного в хі-квадрат, зменшуючи дисперсію часу блоків без зміни середнього;
(3) Механізм призначення кування на основі OP_RETURN, що дозволяє некастодіальний пул-майнінг; та
(4) Динамічне масштабування стиснення, що збільшує складність генерації плотів синхронно з графіком халвінгів для підтримки довгострокових запасів безпеки у міру покращення обладнання.

Bitcoin-PoCX підтримує архітектуру Bitcoin Core через мінімальні, позначені прапорцями модифікації, ізолюючи логіку PoC від існуючого консенсусного коду. Система зберігає монетарну політику Bitcoin, орієнтуючись на 120-секундний інтервал блоків та коригуючи субсидію блоку до 10 BTC. Зменшена субсидія компенсує п'ятикратне збільшення частоти блоків, підтримуючи довгострокову швидкість емісії в одному руслі з оригінальним графіком Bitcoin та зберігаючи максимальну пропозицію ~21 мільйон.

---

## 1. Вступ

### 1.1 Мотивація

Консенсус Proof-of-Work (PoW) Bitcoin довів свою безпеку протягом більш ніж десятиліття, але за значну ціну: майнери повинні постійно витрачати обчислювальні ресурси, що призводить до високого енергоспоживання. Окрім питань ефективності, є ширша мотивація: дослідження альтернативних механізмів консенсусу, що підтримують безпеку при зниженні бар'єру для участі. PoC дозволяє практично будь-кому з масовим обладнанням сховища ефективно майнити, зменшуючи тиск централізації, що спостерігається в майнінгу PoW, домінованому ASIC.

Proof of Capacity (PoC) досягає цього, отримуючи потужність майнінгу із закріплення сховища, а не постійних обчислень. Майнери попередньо обчислюють великі набори дискових хешів — плоти — під час одноразової фази побудови плотів. Майнінг потім полягає в легких пошуках, радикально знижуючи енергоспоживання при збереженні припущень безпеки ресурсного консенсусу.

### 1.2 Інтеграція з Bitcoin Core

Bitcoin-PoCX інтегрує консенсус PoC в Bitcoin Core замість створення нового блокчейну. Цей підхід використовує доведену безпеку Bitcoin Core, зрілий мережевий стек та широко прийнятий інструментарій, зберігаючи модифікації мінімальними та позначеними прапорцями. Логіка PoC ізольована від існуючого консенсусного коду, забезпечуючи, що основна функціональність — валідація блоків, операції гаманця, формати транзакцій — залишається значною мірою незмінною.

### 1.3 Цілі проектування

**Безпека**: Зберегти надійність, еквівалентну Bitcoin; атаки вимагають більшості ємності сховища.

**Ефективність**: Зменшити поточне обчислювальне навантаження до рівня дискового вводу-виводу.

**Доступність**: Дозволити майнінг на масовому обладнанні, знижуючи бар'єри входу.

**Мінімальна інтеграція**: Впровадити консенсус PoC з мінімальним відбитком модифікацій.

---

## 2. Передумови: Proof of Capacity

### 2.1 Історія

Proof of Capacity (PoC) був представлений Burstcoin у 2014 році як енергоефективна альтернатива Proof-of-Work (PoW). Burstcoin продемонстрував, що потужність майнінгу може бути отримана із закріпленого сховища, а не постійного хешування в реальному часі: майнери попередньо обчислювали великі набори даних ("плоти") один раз, а потім майнили, читаючи їх малі фіксовані частини.

Ранні реалізації PoC довели життєздатність концепції, але також виявили, що формат плоту та криптографічна структура критичні для безпеки. Кілька компромісів часу та пам'яті дозволяли атакуючим ефективно майнити з меншим сховищем ніж чесні учасники. Це підкреслило, що безпека PoC залежить від проектування плотів — а не просто від використання сховища як ресурсу.

Спадщина Burstcoin встановила PoC як практичний механізм консенсусу та забезпечила фундамент, на якому будує PoCX.

### 2.2 Основні концепції

Майнінг PoC базується на великих попередньо обчислених файлах плотів, збережених на диску. Ці плоти містять "заморожені обчислення": дороге хешування виконується один раз під час побудови плотів, а майнінг потім полягає в легких дискових читаннях та простій верифікації. Основні елементи включають:

**Nonce:**
Базова одиниця даних плоту. Кожен nonce містить 4096 scoops (256 KiB загалом), згенерованих через Shabal256 з адреси майнера та індексу nonce.

**Scoop:**
64-байтовий сегмент всередині nonce. Для кожного блоку мережа детерміновано вибирає індекс scoop (0–4095) на основі сигнатури генерації попереднього блоку. Тільки цей scoop для кожного nonce потрібно прочитати.

**Сигнатура генерації:**
256-бітове значення, отримане з попереднього блоку. Воно забезпечує ентропію для вибору scoop та запобігає майнерам передбачати майбутні індекси scoops.

**Warp:**
Структурна група з 4096 nonces (1 GiB). Warps є релевантною одиницею для форматів плотів, стійких до стиснення.

### 2.3 Процес майнінгу та конвеєр якості

Майнінг PoC складається з одноразового кроку побудови плотів та легкої рутини для кожного блоку:

**Одноразове налаштування:**
- Генерація плоту: Обчислення nonces через Shabal256 та запис їх на диск.

**Майнінг кожного блоку:**
- Вибір scoop: Визначення індексу scoop із сигнатури генерації.
- Сканування плоту: Читання цього scoop з усіх nonces у плотах майнера.

**Конвеєр якості:**
- Сира якість: Хешування кожного scoop із сигнатурою генерації за допомогою Shabal256Lite для отримання 64-бітового значення якості (менше — краще).
- Дедлайн: Перетворення якості в дедлайн за допомогою базової цілі (параметр, скоригований за складністю, що забезпечує досягнення мережею цільового інтервалу блоків): `deadline = quality / base_target`
- Зігнутий дедлайн: Застосування трансформації Time-Bending для зменшення дисперсії при збереженні очікуваного часу блоку.

**Кування блоку:**
Майнер з найкоротшим (зігнутим) дедлайном кує наступний блок, як тільки цей час мине.

На відміну від PoW, майже всі обчислення відбуваються під час побудови плотів; активний майнінг переважно обмежений диском та споживає дуже мало енергії.

### 2.4 Відомі вразливості в попередніх системах

**Вада розподілу POC1:**
Оригінальний формат POC1 Burstcoin демонстрував структурне зміщення: низькоіндексні scoops були значно дешевшими для переобчислення на льоту ніж високоіндексні. Це ввело нерівномірний компроміс часу та пам'яті, дозволяючи атакуючим зменшити необхідне сховище для цих scoops та порушуючи припущення, що всі попередньо обчислені дані були однаково дорогими.

**Атака XOR-стиснення (POC2):**
У POC2 атакуючий може взяти будь-який набір з 8192 nonces та розділити їх на два блоки по 4096 nonces (A та B). Замість зберігання обох блоків атакуючий зберігає лише похідну структуру: `A ⊕ transpose(B)`, де транспонування міняє місцями індекси scoop та nonce — scoop S nonce N у блоці B стає scoop N nonce S.

Під час майнінгу, коли потрібен scoop S nonce N, атакуючий відновлює його шляхом:
1. Читання збереженого значення XOR на позиції (S, N)
2. Обчислення nonce N з блоку A для отримання scoop S
3. Обчислення nonce S з блоку B для отримання транспонованого scoop N
4. XOR усіх трьох значень для відновлення оригінального 64-байтового scoop

Це зменшує сховище на 50%, вимагаючи лише два обчислення nonces на пошук — вартість значно нижча порогу, необхідного для забезпечення повного попереднього обчислення. Атака життєздатна тому, що обчислення рядка (один nonce, 4096 scoops) недороге, тоді як обчислення стовпця (один scoop через 4096 nonces) вимагало б регенерації всіх nonces. Структура транспонування виявляє цей дисбаланс.

Це продемонструвало потребу у форматі плоту, що запобігає такій структурованій рекомбінації та усуває базовий компроміс часу та пам'яті. Розділ 3.3 описує, як PoCX вирішує та усуває цю слабкість.

### 2.5 Перехід до PoCX

Обмеження попередніх систем PoC чітко показали, що безпечний, справедливий та децентралізований майнінг на сховищі залежить від ретельно спроектованих структур плотів. Bitcoin-PoCX вирішує ці проблеми загартованим форматом плотів, покращеним розподілом дедлайнів та механізмами децентралізованого пул-майнінгу — описаними в наступному розділі.

---

## 3. Формат плотів PoCX

### 3.1 Побудова базового Nonce

Nonce — це 256 KiB структура даних, детерміновано отримана з трьох параметрів: 20-байтового payload адреси, 32-байтового seed та 64-бітового індексу nonce.

Побудова починається з комбінування цих входів та їх хешування Shabal256 для отримання початкового хешу. Цей хеш слугує стартовою точкою для ітеративного процесу розширення: Shabal256 застосовується повторно, кожен крок залежить від раніше згенерованих даних, доки весь 256 KiB буфер не заповниться. Цей ланцюговий процес представляє обчислювальну роботу, виконану під час побудови плотів.

Фінальний крок дифузії хешує завершений буфер та XOR результат через усі байти. Це забезпечує, що весь буфер був обчислений і що майнери не можуть скоротити обчислення. Потім застосовується перемішування PoC2, що міняє місцями нижню та верхню половини кожного scoop для гарантування, що всі scoops вимагають еквівалентних обчислювальних зусиль.

Фінальний nonce складається з 4096 scoops по 64 байти кожен та формує фундаментальну одиницю, що використовується в майнінгу.

### 3.2 Структура плоту, вирівняна для SIMD

Для максимізації пропускної здатності на сучасному обладнанні PoCX організовує дані nonces на диску для полегшення векторизованої обробки. Замість послідовного зберігання кожного nonce, PoCX вирівнює відповідні 4-байтові слова через кілька послідовних nonces суміжно. Це дозволяє одному отриманню з пам'яті надати дані для всіх SIMD-ліній, мінімізуючи промахи кешу та усуваючи накладні витрати scatter-gather.

```
Традиційна структура:
Nonce0: [W0][W1][W2][W3]...
Nonce1: [W0][W1][W2][W3]...
Nonce2: [W0][W1][W2][W3]...

Структура PoCX SIMD:
Word0: [N0][N1][N2]...[N15]
Word1: [N0][N1][N2]...[N15]
Word2: [N0][N1][N2]...[N15]
```

Ця структура приносить користь як CPU, так і GPU майнерам, дозволяючи високопропускну, паралелізовану оцінку scoops при збереженні простого скалярного патерну доступу для верифікації консенсусу. Вона забезпечує, що майнінг обмежений пропускною здатністю сховища, а не обчисленнями CPU, підтримуючи низькоенергетичну природу Proof of Capacity.

### 3.3 Структура Warp та XOR-Transpose кодування

Warp — це фундаментальна одиниця сховища в PoCX, що складається з 4096 nonces (1 GiB). Нестиснутий формат, що називається X0, містить базові nonces точно як вироблені побудовою в Розділі 3.1.

**XOR-Transpose кодування (X1)**

Для усунення структурних компромісів часу та пам'яті, присутніх у ранніх системах PoC, PoCX отримує загартований формат майнінгу, X1, застосовуючи XOR-transpose кодування до пар warps X0.

Для побудови scoop S nonce N у warp X1:

1. Візьміть scoop S nonce N з першого warp X0 (пряма позиція)
2. Візьміть scoop N nonce S з другого warp X0 (транспонована позиція)
3. XOR двох 64-байтових значень для отримання scoop X1

Крок транспонування міняє місцями індекси scoop та nonce. У матричних термінах — де рядки представляють scoops, а стовпці представляють nonces — це поєднує елемент на позиції (S, N) у першому warp з елементом на (N, S) у другому.

**Чому це усуває поверхню атаки стиснення**

XOR-transpose блокує кожен scoop з цілим рядком та цілим стовпцем базових даних X0. Відновлення одного scoop X1 тому вимагає доступу до даних, що охоплюють усі 4096 індексів scoops. Будь-яка спроба обчислити відсутні дані вимагала б регенерації 4096 повних nonces, а не одного nonce — усуваючи асиметричну структуру витрат, експлуатовану атакою XOR для POC2 (Розділ 2.4).

Як результат, зберігання повного warp X1 стає єдиною обчислювально життєздатною стратегією для майнерів, закриваючи компроміс часу та пам'яті, експлуатований у попередніх дизайнах.

### 3.4 Структура диска

Файли плотів PoCX складаються з багатьох послідовних warps X1. Для максимізації операційної ефективності під час майнінгу дані в кожному файлі організовані за scoop: усі дані scoop 0 з кожного warp зберігаються послідовно, потім усі дані scoop 1, і так далі до scoop 4095.

Цей **порядок, послідовний за scoop**, дозволяє майнерам читати повні дані, необхідні для вибраного scoop, одним послідовним дисковим доступом, мінімізуючи час пошуку та максимізуючи пропускну здатність на масових пристроях сховища.

У поєднанні з XOR-transpose кодуванням Розділу 3.3, ця структура забезпечує, що файл одночасно **структурно загартований** та **операційно ефективний**: послідовний порядок scoops підтримує оптимальний дисковий ввід-вивід, тоді як структури пам'яті, вирівняні для SIMD (див. Розділ 3.2), дозволяють високопропускну, паралелізовану оцінку scoops.

### 3.5 Масштабування Proof-of-Work (Xn)

PoCX реалізує масштабоване попереднє обчислення через концепцію рівнів масштабування, позначених Xn, для адаптації до еволюції продуктивності обладнання. Базовий формат X1 представляє першу загартовану XOR-transpose структуру warp.

Кожен рівень масштабування Xn експоненційно збільшує proof-of-work, вбудований у кожен warp відносно X1: робота, необхідна на рівні Xn, становить 2^(n-1) разів від X1. Перехід від Xn до Xn+1 операційно еквівалентний застосуванню XOR через пари суміжних warps, поступово вбудовуючи більше proof-of-work без зміни базового розміру плоту.

Існуючі файли плотів, створені на нижчих рівнях масштабування, все ще можуть використовуватися для майнінгу, але вони вносять пропорційно менше роботи до генерації блоків, відображаючи їх нижчий вбудований proof-of-work. Цей механізм забезпечує, що плоти PoCX залишаються безпечними, гнучкими та економічно збалансованими з часом.

### 3.6 Функціональність Seed

Параметр seed дозволяє кілька неперекривних плотів на адресу без ручної координації.

**Проблема (POC2)**: Майнери повинні були вручну відстежувати діапазони nonces через файли плотів, щоб уникнути перекриття. Перекриваючі nonces витрачають сховище без збільшення потужності майнінгу.

**Рішення**: Кожна пара `(адреса, seed)` визначає незалежний простір ключів. Плоти з різними seeds ніколи не перекриваються, незалежно від діапазонів nonces. Майнери можуть вільно створювати плоти без координації.

---

## 4. Консенсус Proof of Capacity

PoCX розширює консенсус Накамото Bitcoin механізмом доказу, прив'язаного до сховища. Замість витрачання енергії на повторне хешування, майнери закріплюють великі обсяги попередньо обчислених даних — плотів — на диску. Під час генерації блоку вони повинні знайти малу, непередбачувану частину цих даних та трансформувати її в доказ. Майнер, який надає найкращий доказ у межах очікуваного часового вікна, отримує право скувати наступний блок.

Цей розділ описує, як PoCX структурує метадані блоку, отримує непередбачуваність та трансформує статичне сховище в безпечний механізм консенсусу з низькою дисперсією.

### 4.1 Структура блоку

PoCX зберігає звичний заголовок блоку в стилі Bitcoin, але вводить додаткові поля консенсусу, необхідні для майнінгу на основі ємності. Ці поля колективно прив'язують блок до збереженого плоту майнера, складності мережі та криптографічної ентропії, що визначає кожний виклик майнінгу.

На високому рівні блок PoCX містить: висоту блоку, записану явно для спрощення контекстної валідації; сигнатуру генерації, джерело свіжої ентропії, що зв'язує кожен блок з його попередником; базову ціль, що представляє складність мережі в оберненій формі (вищі значення відповідають легшому майнінгу); доказ PoCX, що ідентифікує плот майнера, рівень стиснення, використаний під час побудови плотів, вибраний nonce та якість, отриману з нього; та ключ підпису і підпис, що доводять контроль над ємністю, використаною для кування блоку (або призначеного ключа кування).

Доказ вбудовує всю інформацію, релевантну для консенсусу, необхідну валідаторам для переобчислення виклику, верифікації вибраного scoop та підтвердження отриманої якості. Розширюючи, а не переробляючи структуру блоку, PoCX залишається концептуально вирівняним з Bitcoin, водночас дозволяючи принципово інше джерело роботи майнінгу.

### 4.2 Ланцюг сигнатур генерації

Сигнатура генерації забезпечує непередбачуваність, необхідну для безпечного майнінгу Proof of Capacity. Кожен блок отримує свою сигнатуру генерації з сигнатури та підписанта попереднього блоку, забезпечуючи, що майнери не можуть передбачати майбутні виклики або попередньо обчислювати вигідні регіони плотів:

`generationSignature[n] = SHA256(generationSignature[n-1] || miner_pubkey[n-1])`

Це виробляє послідовність криптографічно сильних, залежних від майнера значень ентропії. Оскільки публічний ключ майнера невідомий до публікації попереднього блоку, жоден учасник не може передбачити майбутні вибори scoops. Це запобігає селективному попередньому обчисленню або стратегічній побудові плотів та забезпечує, що кожен блок вводить справді свіжу роботу майнінгу.

### 4.3 Процес кування

Майнінг у PoCX полягає в трансформації збережених даних у доказ, повністю керований сигнатурою генерації. Хоча процес детермінований, непередбачуваність сигнатури забезпечує, що майнери не можуть готуватися заздалегідь і повинні повторно звертатися до своїх збережених плотів.

**Отримання виклику (вибір Scoop):** Майнер хешує поточну сигнатуру генерації з висотою блоку для отримання індексу scoop у діапазоні 0–4095. Цей індекс визначає, який 64-байтовий сегмент кожного збереженого nonce бере участь у доказі. Оскільки сигнатура генерації залежить від підписанта попереднього блоку, вибір scoop стає відомим лише в момент публікації блоку.

**Оцінка доказу (обчислення якості):** Для кожного nonce в плоті майнер отримує вибраний scoop та хешує його разом із сигнатурою генерації для отримання якості — 64-бітового значення, величина якого визначає конкурентоспроможність майнера. Нижча якість відповідає кращому доказу.

**Формування дедлайну (Time Bending):** Сирий дедлайн пропорційний якості та обернено пропорційний базовій цілі. У застарілих дизайнах PoC ці дедлайни мали сильно скошений експоненційний розподіл, виробляючи довгі хвостові затримки, що не надавали додаткової безпеки. PoCX трансформує сирий дедлайн за допомогою Time Bending (Розділ 4.4), зменшуючи дисперсію та забезпечуючи передбачувані інтервали блоків. Як тільки зігнутий дедлайн мине, майнер кує блок, вбудовуючи доказ та підписуючи його ефективним ключем кування.

### 4.4 Time Bending

Proof of Capacity виробляє експоненційно розподілені дедлайни. Після короткого періоду — зазвичай кількох десятків секунд — кожен майнер вже ідентифікував свій найкращий доказ, і будь-який додатковий час очікування вносить лише затримку, а не безпеку.

Time Bending переформовує розподіл, застосовуючи трансформацію кубічного кореня:

`deadline_bended = scale × (quality / base_target)^(1/3)`

Коефіцієнт масштабу зберігає очікуваний час блоку (120 секунд), водночас драматично зменшуючи дисперсію. Короткі дедлайни розширюються, покращуючи розповсюдження блоків та мережеву безпеку. Довгі дедлайни стискаються, запобігаючи викидам від затримки ланцюга.

![Розподіли часу блоків](blocktime_distributions.svg)

Time Bending підтримує інформаційний вміст базового доказу. Воно не модифікує конкурентоспроможність серед майнерів; воно лише перерозподіляє час очікування для виробництва більш плавних, передбачуваних інтервалів блоків. Реалізація використовує арифметику з фіксованою точкою (формат Q42) та 256-бітові цілі числа для забезпечення детермінованих результатів на всіх платформах.

### 4.5 Налаштування складності

PoCX регулює виробництво блоків за допомогою базової цілі — оберненої міри складності. Очікуваний час блоку пропорційний співвідношенню `quality / base_target`, тому збільшення базової цілі прискорює створення блоків, тоді як зменшення сповільнює ланцюг.

Складність налаштовується кожен блок, використовуючи виміряний час між недавніми блоками порівняно з цільовим інтервалом. Це часте налаштування необхідне тому, що ємність сховища може бути додана або видалена швидко — на відміну від хешрейту Bitcoin, який змінюється повільніше.

Налаштування дотримується двох напрямних обмежень: **Поступовість** — зміни на блок обмежені (максимум ±20%) для уникнення коливань або маніпуляцій; **Загартування** — базова ціль не може перевищувати своє генезисне значення, запобігаючи мережі від коли-небудь зниження складності нижче оригінальних припущень безпеки.

### 4.6 Валідність блоку

Блок у PoCX валідний, коли він представляє верифікований доказ, отриманий зі сховища, узгоджений зі станом консенсусу. Валідатори незалежно переобчислюють вибір scoop, отримують очікувану якість з поданого nonce та метаданих плоту, застосовують трансформацію Time Bending та підтверджують, що майнер мав право скувати блок у заявлений час.

Конкретно, валідний блок вимагає: дедлайн минув з моменту батьківського блоку; подана якість відповідає обчисленій якості для доказу; рівень масштабування відповідає мережевому мінімуму; сигнатура генерації відповідає очікуваному значенню; базова ціль відповідає очікуваному значенню; підпис блоку походить від ефективного підписанта; та coinbase платить на адресу ефективного підписанта.

---

## 5. Призначення кування

### 5.1 Мотивація

Призначення кування дозволяють власникам плотів делегувати повноваження кування блоків без відмови від володіння своїми плотами. Цей механізм дозволяє пул-майнінг та налаштування холодного зберігання при збереженні гарантій безпеки PoCX.

У пул-майнінгу власники плотів можуть авторизувати пул кувати блоки від їх імені. Пул збирає блоки та розподіляє винагороди, але ніколи не отримує опіку над самими плотами. Делегування можна скасувати в будь-який момент, і власники плотів залишаються вільними покинути пул або змінити конфігурації без перебудови плотів.

Призначення також підтримують чітке розділення між холодними та гарячими ключами. Приватний ключ, що контролює плот, може залишатися офлайн, тоді як окремий ключ кування — збережений на онлайн-машині — виробляє блоки. Компрометація ключа кування тому компрометує лише повноваження кування, а не володіння. Плот залишається безпечним, і призначення можна скасувати, негайно закриваючи прогалину безпеки.

Призначення кування таким чином забезпечують операційну гнучкість при підтримці принципу, що контроль над збереженою ємністю ніколи не повинен передаватися посередникам.

### 5.2 Протокол призначення

Призначення оголошуються через транзакції OP_RETURN, щоб уникнути непотрібного зростання набору UTXO. Транзакція призначення вказує адресу плоту та адресу кування, яка авторизована виробляти блоки, використовуючи ємність цього плоту. Транзакція скасування містить лише адресу плоту. В обох випадках власник плоту доводить контроль, підписуючи витрачуваний вхід транзакції.

Кожне призначення проходить через послідовність чітко визначених станів (UNASSIGNED, ASSIGNING, ASSIGNED, REVOKING, REVOKED). Після підтвердження транзакції призначення система входить у коротку фазу активації. Ця затримка — 30 блоків, приблизно одна година — забезпечує стабільність під час гонок блоків та запобігає ворожому швидкому перемиканню ідентичностей кування. Як тільки цей період активації мине, призначення стає активним і залишається таким, доки власник плоту не видасть скасування.

Скасування переходять у довший період затримки в 720 блоків, приблизно один день. Протягом цього часу попередня адреса кування залишається активною. Ця довша затримка забезпечує операційну стабільність для пулів, запобігаючи стратегічному "стрибанню призначень" та надаючи постачальникам інфраструктури достатню визначеність для ефективної роботи. Після закінчення затримки скасування воно завершується, і власник плоту вільний призначити новий ключ кування.

Стан призначення підтримується в структурі рівня консенсусу, паралельній набору UTXO, та підтримує дані скасування для безпечної обробки реорганізацій ланцюга.

### 5.3 Правила валідації

Для кожного блоку валідатори визначають ефективного підписанта — адресу, яка повинна підписати блок та отримати винагороду coinbase. Цей підписант залежить виключно від стану призначення на висоті блоку.

Якщо призначення не існує або призначення ще не завершило свою фазу активації, власник плоту залишається ефективним підписантом. Як тільки призначення стає активним, призначена адреса кування повинна підписувати. Під час скасування адреса кування продовжує підписувати, доки затримка скасування не мине. Тільки тоді повноваження повертаються до власника плоту.

Валідатори забезпечують, що підпис блоку вироблений ефективним підписантом, що coinbase платить на ту саму адресу, і що всі переходи дотримуються визначених затримок активації та скасування. Тільки власник плоту може створювати або скасовувати призначення; ключі кування не можуть модифікувати або розширювати власні дозволи.

Призначення кування таким чином вводять гнучке делегування без введення довіри. Володіння базовою ємністю завжди залишається криптографічно закріпленим за власником плоту, тоді як повноваження кування можуть бути делеговані, ротовані або скасовані відповідно до операційних потреб.

---

## 6. Динамічне масштабування

У міру еволюції обладнання вартість обчислення плотів зменшується відносно читання попередньо обчисленої роботи з диска. Без контрзаходів атакуючі врешті могли б генерувати докази на льоту швидше ніж майнери, що читають збережену роботу, підриваючи модель безпеки Proof of Capacity.

Для збереження запланованого запасу безпеки PoCX реалізує графік масштабування: мінімальний необхідний рівень масштабування для плотів збільшується з часом. Кожен рівень масштабування Xn, як описано в Розділі 3.5, вбудовує експоненційно більше proof-of-work у структуру плоту, забезпечуючи, що майнери продовжують закріплювати значні ресурси сховища навіть коли обчислення стають дешевшими.

Графік вирівнюється з економічними стимулами мережі, зокрема халвінгами винагород за блоки. У міру зменшення винагороди за блок мінімальний рівень поступово збільшується, зберігаючи баланс між зусиллями побудови плотів та потенціалом майнінгу:

| Період | Роки | Халвінги | Мін. масштабування | Множник роботи плоту |
|--------|------|----------|-------------------|----------------------|
| Епоха 0 | 0-4 | 0 | X1 | 2× базовий |
| Епоха 1 | 4-12 | 1-2 | X2 | 4× базовий |
| Епоха 2 | 12-28 | 3-6 | X3 | 8× базовий |
| Епоха 3 | 28-60 | 7-14 | X4 | 16× базовий |
| Епоха 4 | 60-124 | 15-30 | X5 | 32× базовий |
| Епоха 5 | 124+ | 31+ | X6 | 64× базовий |

Майнери можуть опціонально готувати плоти, що перевищують поточний мінімум на один рівень, дозволяючи їм планувати заздалегідь та уникати негайних оновлень, коли мережа переходить до наступної епохи. Цей опціональний крок не надає додаткової переваги в плані ймовірності блоку — він лише дозволяє плавніший операційний перехід.

Блоки, що містять докази нижче мінімального рівня масштабування для їх висоти, вважаються невалідними. Валідатори перевіряють заявлений рівень масштабування в доказі проти поточної мережевої вимоги під час валідації консенсусу, забезпечуючи, що всі майнери, що беруть участь, відповідають еволюційним очікуванням безпеки.

---

## 7. Архітектура майнінгу

PoCX розділяє операції, критичні для консенсусу, від ресурсомістких задач майнінгу, дозволяючи як безпеку, так і ефективність. Вузол підтримує блокчейн, валідує блоки, управляє mempool та надає RPC-інтерфейс. Зовнішні майнери обробляють зберігання плотів, читання scoops, обчислення якості та управління дедлайнами. Це розділення підтримує логіку консенсусу простою та придатною для аудиту, водночас дозволяючи майнерам оптимізувати для дискової пропускної здатності.

### 7.1 RPC-інтерфейс майнінгу

Майнери взаємодіють з вузлом через мінімальний набір RPC-викликів. RPC get_mining_info надає поточну висоту блоку, сигнатуру генерації, базову ціль, цільовий дедлайн та допустимий діапазон рівнів масштабування плотів. Використовуючи цю інформацію, майнери обчислюють кандидатні nonces. RPC submit_nonce дозволяє майнерам подати запропоноване рішення, включаючи ідентифікатор плоту, індекс nonce, рівень масштабування та обліковий запис майнера. Вузол оцінює подання та відповідає обчисленим дедлайном, якщо доказ валідний.

### 7.2 Планувальник кування

Вузол підтримує планувальник кування, який відстежує вхідні подання та зберігає лише найкраще рішення для кожної висоти блоку. Подані nonces ставляться в чергу з вбудованими захистами проти флудингу подань або атак відмови в обслуговуванні. Планувальник чекає, доки обчислений дедлайн мине або надійде краще рішення, після чого він збирає блок, підписує його ефективним ключем кування та публікує в мережу.

### 7.3 Захисне кування

Для запобігання атак на таймінг або стимулів для маніпуляцій з годинником PoCX реалізує захисне кування. Якщо конкуруючий блок надходить для тієї самої висоти, планувальник порівнює локальне рішення з новим блоком. Якщо локальна якість краща, вузол негайно кує, замість очікування оригінального дедлайну. Це забезпечує, що майнери не можуть отримати перевагу, просто налаштовуючи локальні годинники; найкраще рішення завжди переможе, зберігаючи справедливість та мережеву безпеку.

---

## 8. Аналіз безпеки

### 8.1 Модель загроз

PoCX моделює противників зі значними, але обмеженими можливостями. Атакуючі можуть намагатися перевантажити мережу невалідними транзакціями, деформованими блоками або сфабрикованими доказами для стрес-тестування шляхів валідації. Вони можуть вільно маніпулювати своїми локальними годинниками та можуть намагатися експлуатувати крайні випадки в поведінці консенсусу, такі як обробка міток часу, динаміка налаштування складності або правила реорганізації. Очікується також, що противники будуть зондувати можливості переписування історії через цільові форки ланцюга.

Модель передбачає, що жодна окрема сторона не контролює більшість загальної ємності сховища мережі. Як і з будь-яким ресурсним механізмом консенсусу, атакуючий з 51% ємності може односторонньо реорганізувати ланцюг; це фундаментальне обмеження не є специфічним для PoCX. PoCX також передбачає, що атакуючі не можуть обчислювати дані плотів швидше ніж чесні майнери можуть читати їх з диска. Графік масштабування (Розділ 6) забезпечує, що обчислювальний розрив, необхідний для безпеки, зростає з часом у міру покращення обладнання.

Наступні розділи детально розглядають кожен основний клас атак та описують контрзаходи, вбудовані в PoCX.

### 8.2 Атаки на ємність

Як і PoW, атакуючий з більшістю ємності може переписувати історію (атака 51%). Досягнення цього вимагає придбання фізичного сховища більшого ніж чесна мережа — дороге та логістично складне підприємство. Як тільки обладнання отримано, операційні витрати низькі, але початкові інвестиції створюють сильний економічний стимул поводитися чесно: підрив ланцюга пошкодив би вартість власної бази активів атакуючого.

PoC також уникає проблеми "nothing-at-stake", асоційованої з PoS. Хоча майнери можуть сканувати плоти проти кількох конкуруючих форків, кожне сканування споживає реальний час — зазвичай порядку десятків секунд на ланцюг. З 120-секундним інтервалом блоків це внутрішньо обмежує мульти-форк майнінг, і спроба майнити багато форків одночасно погіршує продуктивність на всіх них. Майнінг форків тому не безкоштовний; він фундаментально обмежений пропускною здатністю вводу-виводу.

Навіть якщо майбутнє обладнання дозволить майже миттєве сканування плотів (напр., високошвидкісні SSD), атакуючий все одно стоятиме перед значною вимогою фізичних ресурсів для контролю більшості мережевої ємності, роблячи атаку в стилі 51% дорогою та логістично складною.

Нарешті, атаки на ємність значно важче орендувати ніж атаки на хешрейт. GPU-обчислення можна придбати на вимогу та миттєво перенаправити на будь-який ланцюг PoW. На відміну від цього, PoC вимагає фізичного обладнання, часомісткої побудови плотів та постійних операцій вводу-виводу. Ці обмеження роблять короткострокові, опортуністичні атаки значно менш здійсненними.

### 8.3 Атаки на таймінг

Таймінг відіграє більш критичну роль у Proof of Capacity ніж у Proof of Work. У PoW мітки часу переважно впливають на налаштування складності; у PoC вони визначають чи минув дедлайн майнера і чи має блок право на кування. Дедлайни вимірюються відносно мітки часу батьківського блоку, але локальний годинник вузла використовується для судження чи вхідний блок занадто далеко в майбутньому. З цієї причини PoCX забезпечує жорсткий допуск міток часу: блоки не можуть відхилятися більш ніж на 15 секунд від локального годинника вузла (порівняно з 2-годинним вікном Bitcoin). Цей ліміт працює в обох напрямках — блоки занадто далеко в майбутньому відхиляються, і вузли з повільними годинниками можуть неправильно відхиляти валідні вхідні блоки.

Вузли тому повинні синхронізувати свої годинники за допомогою NTP або еквівалентного джерела часу. PoCX навмисно уникає покладання на внутрішньомережеві джерела часу для запобігання атакуючим від маніпулювання сприйняттям мережевого часу. Вузли моніторять власний дрейф та видають попередження, якщо локальний годинник починає відхилятися від недавніх міток часу блоків.

Прискорення годинника — запуск швидкого локального годинника для кування трохи раніше — надає лише мінімальну перевагу. В межах дозволеного допуску захисне кування (Розділ 7.3) забезпечує, що майнер з кращим рішенням негайно опублікує, побачивши гірший ранній блок. Швидкий годинник допомагає майнеру публікувати вже виграшне рішення на кілька секунд раніше; він не може перетворити гірший доказ на виграшний.

Спроби маніпулювати складністю через мітки часу обмежені обмеженням налаштування ±20% на блок та 24-блоковим ковзним вікном, запобігаючи майнерам значно впливати на складність через короткострокові ігри з таймінгом.

### 8.4 Атаки компромісу часу та пам'яті

Компроміси часу та пам'яті намагаються зменшити вимоги до сховища шляхом переобчислення частин плоту на вимогу. Попередні системи Proof of Capacity були вразливі до таких атак, найбільш помітно вада дисбалансу scoops POC1 та атака XOR-transpose стиснення POC2 (Розділ 2.4). Обидві експлуатували асиметрії в тому, наскільки дорогим було регенерувати певні частини даних плоту, дозволяючи противникам урізати сховище, сплачуючи лише малий обчислювальний штраф. Також альтернативні формати плотів до PoC2 страждають від подібних слабкостей TMTO; видатним прикладом є Chia, формат плотів якої може бути довільно зменшений в коефіцієнт більший за 4.

PoCX повністю усуває ці поверхні атак через свою побудову nonces та формат warp. Всередині кожного nonce фінальний крок дифузії хешує повністю обчислений буфер та XOR результат через усі байти, забезпечуючи, що кожна частина буфера залежить від кожної іншої частини і не може бути скорочена. Після цього перемішування PoC2 міняє місцями нижню та верхню половини кожного scoop, вирівнюючи обчислювальну вартість відновлення будь-якого scoop.

PoCX далі усуває атаку XOR–transpose стиснення POC2, отримуючи свій загартований формат X1, де кожен scoop є XOR прямої та транспонованої позиції через пари warps; це блокує кожен scoop з цілим рядком та цілим стовпцем базових даних X0, роблячи реконструкцію вимагаючою тисяч повних nonces та тим самим повністю усуваючи асиметричний компроміс часу та пам'яті.

Як результат, зберігання повного плоту є єдиною обчислювально життєздатною стратегією для майнерів. Жоден відомий скорочений шлях — чи то часткова побудова плотів, селективна регенерація, структуроване стиснення чи гібридні обчислювально-сховищні підходи — не надає значної переваги. PoCX забезпечує, що майнінг залишається строго обмеженим сховищем і що ємність відображає реальне, фізичне закріплення.

### 8.5 Атаки на призначення

PoCX використовує детерміністичний скінченний автомат для управління всіма призначеннями плот-до-кувача. Кожне призначення проходить через чітко визначені стани — UNASSIGNED → ASSIGNING → ASSIGNED → REVOKING → REVOKED — з забезпеченими затримками активації та скасування. Це забезпечує, що майнер не може миттєво змінювати призначення для обману системи або швидко перемикати повноваження кування.

Оскільки всі переходи вимагають криптографічних доказів — конкретно, підписів власником плоту, що верифікуються проти вхідного UTXO — мережа може довіряти легітимності кожного призначення. Спроби обійти скінченний автомат або підробити призначення автоматично відхиляються під час валідації консенсусу. Атаки повтору також запобігаються стандартними захистами повтору транзакцій у стилі Bitcoin, забезпечуючи, що кожна дія призначення унікально прив'язана до валідного невитраченого входу.

Комбінація управління скінченним автоматом, забезпечених затримок та криптографічного доказу робить шахрайство на основі призначень практично неможливим: майнери не можуть захоплювати призначення, виконувати швидке перепризначення під час гонок блоків або обходити графіки скасування.

### 8.6 Безпека підписів

Підписи блоків у PoCX слугують критичним зв'язком між доказом та ефективним ключем кування, забезпечуючи, що тільки авторизовані майнери можуть виробляти валідні блоки.

Для запобігання атак ковкості підписи виключені з обчислення хешу блоку. Це усуває ризики ковких підписів, які могли б підірвати валідацію або дозволити атаки заміни блоків.

Для пом'якшення векторів відмови в обслуговуванні розміри підписів та публічних ключів фіксовані — 65 байтів для компактних підписів та 33 байти для стиснутих публічних ключів — запобігаючи атакуючим від роздування блоків для спричинення вичерпання ресурсів або уповільнення мережевого розповсюдження.

---

## 9. Реалізація

PoCX реалізовано як модульне розширення Bitcoin Core, з усім релевантним кодом, що міститься в власному виділеному підкаталозі та активується через прапорець функції. Цей дизайн зберігає цілісність оригінального коду, дозволяючи PoCX бути увімкненим або вимкненим чисто, що спрощує тестування, аудит та синхронізацію з upstream змінами.

Інтеграція торкається лише важливих точок, необхідних для підтримки Proof of Capacity. Заголовок блоку був розширений для включення специфічних для PoCX полів, і валідація консенсусу була адаптована для обробки доказів на основі сховища поряд з традиційними перевірками Bitcoin. Система кування, відповідальна за управління дедлайнами, планування та подання майнерів, повністю міститься в модулях PoCX, тоді як розширення RPC надають функціональність майнінгу та призначень зовнішнім клієнтам. Для користувачів інтерфейс гаманця був покращений для управління призначеннями через транзакції OP_RETURN, дозволяючи безшовну взаємодію з новими функціями консенсусу.

Усі операції, критичні для консенсусу, реалізовані на детерміністичному C++ без зовнішніх залежностей, забезпечуючи крос-платформну консистентність. Shabal256 використовується для хешування, тоді як Time Bending та обчислення якості покладаються на арифметику з фіксованою точкою та 256-бітові операції. Криптографічні операції, такі як верифікація підписів, використовують існуючу бібліотеку secp256k1 Bitcoin Core.

Ізолюючи функціональність PoCX таким чином, реалізація залишається придатною для аудиту, підтримуваною та повністю сумісною з поточною розробкою Bitcoin Core, демонструючи, що принципово новий механізм консенсусу, обмежений сховищем, може співіснувати зі зрілою кодовою базою proof-of-work без порушення її цілісності чи зручності використання.

---

## 10. Параметри мережі

PoCX будує на мережевій інфраструктурі Bitcoin та повторно використовує її фреймворк параметрів ланцюга. Для підтримки майнінгу на основі ємності, інтервалів блоків, обробки призначень та масштабування плотів кілька параметрів були розширені або перевизначені. Це включає цільовий час блоку, початкову субсидію, графік халвінгу, затримки активації та скасування призначень, а також ідентифікатори мережі, такі як магічні байти, порти та префікси Bech32. Середовища testnet та regtest далі налаштовують ці параметри для швидкої ітерації та тестування з низькою ємністю.

Таблиці нижче підсумовують результуючі налаштування mainnet, testnet та regtest, підкреслюючи, як PoCX адаптує основні параметри Bitcoin до моделі консенсусу, обмеженої сховищем.

### 10.1 Mainnet

| Параметр | Значення |
|----------|----------|
| Магічні байти | `0xa7 0x3c 0x91 0x5e` |
| Порт за замовчуванням | 8888 |
| Bech32 HRP | `pocx` |
| Цільовий час блоку | 120 секунд |
| Початкова субсидія | 10 BTC |
| Інтервал халвінгу | 1050000 блоків (~4 роки) |
| Загальна пропозиція | ~21 мільйон BTC |
| Активація призначення | 30 блоків |
| Скасування призначення | 720 блоків |
| Ковзне вікно | 24 блоки |

### 10.2 Testnet

| Параметр | Значення |
|----------|----------|
| Магічні байти | `0x6d 0xf2 0x48 0xb3` |
| Порт за замовчуванням | 18888 |
| Bech32 HRP | `tpocx` |
| Цільовий час блоку | 120 секунд |
| Інші параметри | Такі ж як mainnet |

### 10.3 Regtest

| Параметр | Значення |
|----------|----------|
| Магічні байти | `0xfa 0xbf 0xb5 0xda` |
| Порт за замовчуванням | 18444 |
| Bech32 HRP | `rpocx` |
| Цільовий час блоку | 1 секунда |
| Інтервал халвінгу | 500 блоків |
| Активація призначення | 4 блоки |
| Скасування призначення | 8 блоків |
| Режим низької ємності | Увімкнено (~4 MB плоти) |

---

## 11. Пов'язані роботи

Протягом років кілька блокчейн та консенсусних проектів досліджували моделі майнінгу на основі сховища або гібридні. PoCX будує на цій спадщині, водночас вводячи покращення безпеки, ефективності та сумісності.

**Burstcoin / Signum.** Burstcoin представив першу практичну систему Proof-of-Capacity (PoC) у 2014 році, визначивши основні концепції, такі як плоти, nonces, scoops та майнінг на основі дедлайнів. Його наступники, зокрема Signum (раніше Burstcoin), розширили екосистему та врешті еволюціонували в те, що відоме як Proof-of-Commitment (PoC+), поєднуючи закріплення сховища з опціональним стейкінгом для впливу на ефективну ємність. PoCX успадковує фундамент майнінгу на основі сховища від цих проектів, але значно відрізняється загартованим форматом плотів (XOR-transpose кодування), динамічним масштабуванням роботи плотів, згладжуванням дедлайнів ("Time Bending") та гнучкою системою призначень — все це закріплюючись у кодовій базі Bitcoin Core, а не підтримуючи окремий форк мережі.

**Chia.** Chia реалізує Proof of Space and Time, поєднуючи дискові докази сховища з часовим компонентом, забезпеченим Verifiable Delay Functions (VDFs). Її дизайн вирішує певні питання повторного використання доказів та генерації свіжих викликів, відмінні від класичного PoC. PoCX не приймає цю прив'язану до часу модель доказів; натомість вона підтримує консенсус, обмежений сховищем, з передбачуваними інтервалами, оптимізованими для довгострокової сумісності з економікою UTXO та інструментарієм, похідним від Bitcoin.

**Spacemesh.** Spacemesh пропонує схему Proof-of-Space-Time (PoST) з використанням топології мережі на основі DAG (mesh). У цій моделі учасники повинні періодично доводити, що виділене сховище залишається недоторканим з часом, замість покладання на один попередньо обчислений набір даних. PoCX, навпаки, верифікує закріплення сховища лише під час блоку — із загартованими форматами плотів та ретельною валідацією доказів — уникаючи накладних витрат постійних доказів сховища при збереженні ефективності та децентралізації.

---

## 12. Висновок

Bitcoin-PoCX демонструє, що енергоефективний консенсус може бути інтегрований у Bitcoin Core при збереженні властивостей безпеки та економічної моделі. Ключові внески включають XOR-transpose кодування (примушує атакуючих обчислювати 4096 nonces на пошук, усуваючи атаку стиснення), алгоритм Time Bending (трансформація розподілу зменшує дисперсію часу блоків), систему призначення кування (делегування на основі OP_RETURN дозволяє некастодіальний пул-майнінг), динамічне масштабування (вирівняне з халвінгами для підтримки запасів безпеки) та мінімальну інтеграцію (код, позначений прапорцями, ізольований у виділеному каталозі).

Система наразі у фазі тестової мережі. Потужність майнінгу походить з ємності сховища, а не хешрейту, зменшуючи енергоспоживання на порядки величини при підтримці доведеної економічної моделі Bitcoin.

---

## Посилання

Bitcoin Core. *Bitcoin Core Repository.* https://github.com/bitcoin/bitcoin

Burstcoin. *Proof of Capacity Technical Documentation.* 2014.

NIST. *SHA-3 Competition: Shabal.* 2008.

Cohen, B., Pietrzak, K. *The Chia Network Blockchain.* 2019.

Spacemesh. *Spacemesh Protocol Documentation.* 2021.

PoC Consortium. *PoCX Framework.* https://github.com/PoC-Consortium/pocx

PoC Consortium. *Bitcoin-PoCX Integration.* https://github.com/PoC-Consortium/bitcoin-pocx

---

**Ліцензія**: MIT
**Організація**: Proof of Capacity Consortium
**Статус**: Фаза тестової мережі
