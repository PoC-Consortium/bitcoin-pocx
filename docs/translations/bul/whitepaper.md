# Bitcoin-PoCX: Енергийно ефективен консенсус за Bitcoin Core

**Версия**: 2.0 Чернова
**Дата**: Декември 2025
**Организация**: Proof of Capacity Consortium

---

## Резюме

Proof-of-Work (PoW) консенсусът на Bitcoin предоставя стабилна сигурност, но консумира значителна енергия поради непрекъснато хеш изчисление в реално време. Представяме Bitcoin-PoCX, форк на Bitcoin, който заменя PoW с Proof of Capacity (PoC), където миньорите предварително изчисляват и съхраняват големи набори от хешове на диска по време на plotting и впоследствие копаят чрез извършване на леки справки вместо непрекъснато хеширане. Чрез преместване на изчислението от фазата на копаене към еднократна фаза на plotting, Bitcoin-PoCX драстично намалява консумацията на енергия, като същевременно позволява копаене с масов хардуер, понижавайки бариерата за участие и смекчавайки централизационния натиск, присъщ на доминирания от ASIC PoW, като същевременно запазва предположенията за сигурност и икономическо поведение на Bitcoin.

Нашата имплементация въвежда няколко ключови иновации:
(1) Закален формат на plot, който елиминира всички известни атаки с компромис време-памет в съществуващите PoC системи, гарантирайки че ефективната сила за копаене остава строго пропорционална на ангажирания капацитет за съхранение;
(2) Алгоритъм Time-Bending, който трансформира разпределенията на крайни срокове от експоненциално към хи-квадрат, намалявайки вариацията на времето на блок без да променя средната стойност;
(3) Механизъм за делегиране на подписване, базиран на OP_RETURN, позволяващ некустодиално копаене в пул; и
(4) Динамично мащабиране на компресия, което увеличава трудността на генериране на plot в съответствие с графици за halving за поддържане на дългосрочни маржове на сигурност при подобряване на хардуера.

Bitcoin-PoCX поддържа архитектурата на Bitcoin Core чрез минимални модификации с feature-flag, изолирайки PoC логиката от съществуващия консенсусен код. Системата запазва паричната политика на Bitcoin, като насочва към 120-секунден интервал между блоковете и коригира субсидията за блок на 10 BTC. Намалената субсидия компенсира петкратното увеличение на честотата на блоковете, запазвайки дългосрочната скорост на емисия в съответствие с оригиналния график на Bitcoin и поддържайки максималното предлагане от ~21 милиона.

---

## 1. Въведение

### 1.1 Мотивация

Proof-of-Work (PoW) консенсусът на Bitcoin се е доказал като сигурен за повече от десетилетие, но с значителна цена: миньорите трябва непрекъснато да изразходват изчислителни ресурси, което води до висока консумация на енергия. Отвъд съображенията за ефективност има по-широка мотивация: проучване на алтернативни консенсусни механизми, които поддържат сигурността, като същевременно понижават бариерата за участие. PoC позволява на практически всеки с масов хардуер за съхранение да копае ефективно, намалявайки централизационния натиск, наблюдаван при доминираното от ASIC PoW копаене.

Proof of Capacity (PoC) постига това, като извлича сила за копаене от ангажимент за съхранение, а не от непрекъснато изчисление. Миньорите предварително изчисляват големи набори от хешове, съхранени на диск — plots — по време на еднократна фаза на plotting. Копаенето след това се състои от леки справки, драстично намалявайки използването на енергия, като същевременно запазва предположенията за сигурност на консенсус, базиран на ресурси.

### 1.2 Интеграция с Bitcoin Core

Bitcoin-PoCX интегрира PoC консенсус в Bitcoin Core, вместо да създава нов блокчейн. Този подход използва доказаната сигурност, зрялата мрежова инфраструктура и широко възприетите инструменти на Bitcoin Core, като същевременно запазва модификациите минимални и с feature-flag. PoC логиката е изолирана от съществуващия консенсусен код, гарантирайки че основната функционалност — валидация на блокове, операции с портфейл, формати на транзакции — остава до голяма степен непроменена.

### 1.3 Цели на дизайна

**Сигурност**: Запазване на устойчивост, еквивалентна на Bitcoin; атаките изискват мажоритарен капацитет за съхранение.

**Ефективност**: Намаляване на текущото изчислително натоварване до нива на дискови I/O.

**Достъпност**: Позволяване на копаене с масов хардуер, понижавайки бариерите за навлизане.

**Минимална интеграция**: Въвеждане на PoC консенсус с минимален отпечатък на модификация.

---

## 2. Фон: Proof of Capacity

### 2.1 История

Proof of Capacity (PoC) беше въведен от Burstcoin през 2014 като енергийно ефективна алтернатива на Proof-of-Work (PoW). Burstcoin демонстрира, че силата за копаене може да се извлича от ангажирано съхранение, а не от непрекъснато хеширане в реално време: миньорите предварително изчисляват големи набори от данни ("plots") веднъж и след това копаят, като четат малки, фиксирани части от тях.

Ранните PoC имплементации доказаха жизнеспособността на концепцията, но също разкриха, че форматът на plot и криптографската структура са критични за сигурността. Няколко компромиса време-памет позволиха на атакуващите да копаят ефективно с по-малко съхранение от честните участници. Това подчерта, че сигурността на PoC зависи от дизайна на plot — не просто от използването на съхранение като ресурс.

Наследството на Burstcoin установи PoC като практичен консенсусен механизъм и предостави основата, върху която PoCX надгражда.

### 2.2 Основни концепции

PoC копаенето се базира на големи, предварително изчислени plot файлове, съхранени на диск. Тези plots съдържат "замразено изчисление": скъпото хеширане се извършва веднъж по време на plotting, а копаенето след това се състои от леки четения от диска и проста верификация. Основните елементи включват:

**Nonce:**
Основната единица от plot данни. Всеки nonce съдържа 4096 scoops (общо 256 KiB), генерирани чрез Shabal256 от адреса на миньора и индекса на nonce.

**Scoop:**
64-байтов сегмент вътре в nonce. За всеки блок мрежата детерминистично избира scoop индекс (0–4095) на базата на генерационния подпис на предишния блок. Само този scoop за nonce трябва да се чете.

**Генерационен подпис:**
256-битова стойност, извлечена от предишния блок. Предоставя ентропия за избор на scoop и предотвратява миньорите да предвиждат бъдещи scoop индекси.

**Warp:**
Структурна група от 4096 nonces (1 GiB). Warps са релевантната единица за формати на plot, устойчиви на компресия.

### 2.3 Процес на копаене и поток на качество

PoC копаенето се състои от еднократна стъпка на plotting и лека рутина за всеки блок:

**Еднократна настройка:**
- Генериране на plot: Изчисляване на nonces чрез Shabal256 и записването им на диска.

**Копаене за всеки блок:**
- Избор на scoop: Определяне на scoop индекса от генерационния подпис.
- Сканиране на plot: Четене на този scoop от всички nonces в plots на миньора.

**Поток на качество:**
- Сурово качество: Хеширане на всеки scoop с генерационния подпис, използвайки Shabal256Lite, за получаване на 64-битова стойност на качество (по-ниско е по-добре).
- Краен срок: Конвертиране на качество в краен срок, използвайки базовата цел (параметър, коригиран за трудност, гарантиращ че мрежата достига целевия интервал между блоковете): `deadline = quality / base_target`
- Огънат краен срок: Прилагане на трансформацията Time-Bending за намаляване на вариацията, като се запазва очакваното време на блок.

**Подписване на блок:**
Миньорът с най-краткия (огънат) краен срок подписва следващия блок, когато това време изтече.

За разлика от PoW, почти цялото изчисление се случва по време на plotting; активното копаене е предимно свързано с диска и с много ниска консумация на енергия.

### 2.4 Известни уязвимости в предишни системи

**Дефект в разпределението на POC1:**
Оригиналният Burstcoin POC1 формат показваше структурно изкривяване: scoops с ниски индекси бяха значително по-евтини за преизчисляване в движение от scoops с високи индекси. Това въведе неравномерен компромис време-памет, позволявайки на атакуващите да намалят изискванията за съхранение за тези scoops и нарушавайки предположението, че всички предварително изчислени данни са еднакво скъпи.

**XOR атака за компресия (POC2):**
В POC2 атакуващ може да вземе произволен набор от 8192 nonces и да ги раздели на два блока от 4096 nonces (A и B). Вместо да съхранява и двата блока, атакуващият съхранява само извлечена структура: `A ⊕ transpose(B)`, където транспонирането разменя scoop и nonce индексите — scoop S от nonce N в блок B става scoop N от nonce S.

По време на копаене, когато е необходим scoop S от nonce N, атакуващият го реконструира чрез:
1. Четене на съхранената XOR стойност на позиция (S, N)
2. Изчисляване на nonce N от блок A за получаване на scoop S
3. Изчисляване на nonce S от блок B за получаване на транспонирания scoop N
4. XOR на трите стойности за възстановяване на оригиналния 64-байтов scoop

Това намалява съхранението с 50%, като изисква само две изчисления на nonce за справка — разход далеч под прага, необходим за налагане на пълно предварително изчисление. Атаката е жизнеспособна, защото изчисляването на ред (един nonce, 4096 scoops) е евтино, докато изчисляването на колона (един scoop през 4096 nonces) би изисквало регенериране на всички nonces. Транспонираната структура разкрива този дисбаланс.

Това демонстрира необходимостта от формат на plot, който предотвратява такова структурирано рекомбиниране и премахва подлежащия компромис време-памет. Раздел 3.3 описва как PoCX адресира и разрешава тази слабост.

### 2.5 Преход към PoCX

Ограниченията на по-ранните PoC системи ясно показаха, че сигурното, справедливо и децентрализирано копаене със съхранение зависи от внимателно проектирани plot структури. Bitcoin-PoCX адресира тези проблеми със закален формат на plot, подобрено разпределение на крайни срокове и механизми за децентрализирано копаене в пул — описани в следващия раздел.

---

## 3. PoCX формат на Plot

### 3.1 Конструкция на базов Nonce

Nonce е 256 KiB структура от данни, извлечена детерминистично от три параметъра: 20-байтов адресен payload, 32-байтов seed и 64-битов nonce индекс.

Конструкцията започва чрез комбиниране на тези входове и хеширането им с Shabal256 за получаване на начален хеш. Този хеш служи като начална точка за итеративен процес на разширяване: Shabal256 се прилага многократно, като всяка стъпка зависи от предварително генерирани данни, докато целият 256 KiB буфер бъде попълнен. Този верижен процес представлява изчислителната работа, извършена по време на plotting.

Финална стъпка на дифузия хешира завършения буфер и XOR-ва резултата през всички байтове. Това гарантира, че целият буфер е бил изчислен и че миньорите не могат да съкратят изчислението. След това се прилага POC2 размесването, разменяйки долните и горните половини на всеки scoop, за да се гарантира, че всички scoops изискват еквивалентно изчислително усилие.

Финалният nonce се състои от 4096 scoops по 64 байта всеки и формира основната единица, използвана при копаене.

### 3.2 SIMD-подравнен формат на Plot

За максимизиране на пропускателната способност на модерен хардуер, PoCX организира nonce данните на диска за улесняване на векторизирана обработка. Вместо да съхранява всеки nonce последователно, PoCX подравнява съответстващи 4-байтови думи през множество последователни nonces съседно. Това позволява на единично извличане от паметта да предостави данни за всички SIMD ленти, минимизирайки пропуски на кеш и елиминирайки scatter-gather overhead.

```
Традиционен формат:
Nonce0: [W0][W1][W2][W3]...
Nonce1: [W0][W1][W2][W3]...
Nonce2: [W0][W1][W2][W3]...

PoCX SIMD формат:
Word0: [N0][N1][N2]...[N15]
Word1: [N0][N1][N2]...[N15]
Word2: [N0][N1][N2]...[N15]
```

Този формат облагодетелства както CPU, така и GPU миньори, позволявайки високопроизводително, паралелизирано оценяване на scoop, като същевременно запазва прост скаларен модел на достъп за консенсусна верификация. Това гарантира, че копаенето е ограничено от пропускателната способност на съхранението, а не от CPU изчисление, поддържайки нискоенергийната природа на Proof of Capacity.

### 3.3 Warp структура и XOR-Transpose кодиране

Warp е основната единица за съхранение в PoCX, състояща се от 4096 nonces (1 GiB). Некомпресираният формат, наричан X0, съдържа базови nonces точно както са произведени от конструкцията в Раздел 3.1.

**XOR-Transpose кодиране (X1)**

За премахване на структурните компромиси време-памет, присъстващи в по-ранни PoC системи, PoCX извлича закален формат за копаене, X1, чрез прилагане на XOR-transpose кодиране към двойки X0 warps.

За конструиране на scoop S от nonce N в X1 warp:

1. Вземете scoop S от nonce N от първия X0 warp (директна позиция)
2. Вземете scoop N от nonce S от втория X0 warp (транспонирана позиция)
3. XOR-вайте двете 64-байтови стойности за получаване на X1 scoop

Стъпката на транспониране разменя scoop и nonce индекси. В матрични термини — където редовете представляват scoops, а колоните представляват nonces — тя комбинира елемента на позиция (S, N) в първия warp с елемента на (N, S) във втория.

**Защо това елиминира повърхността за атака с компресия**

XOR-transpose свързва всеки scoop с цял ред и цяла колона от подлежащите X0 данни. Възстановяването на един X1 scoop следователно изисква достъп до данни, обхващащи всички 4096 scoop индекса. Всеки опит за изчисляване на липсващи данни би изисквал регенериране на 4096 пълни nonces, а не един nonce — премахвайки асиметричната структура на разходите, експлоатирана от XOR атаката за POC2 (Раздел 2.4).

В резултат съхраняването на пълния X1 warp става единствената изчислително жизнеспособна стратегия за миньорите, затваряйки компромиса време-памет, експлоатиран в предишни дизайни.

### 3.4 Формат на диска

PoCX plot файловете се състоят от много последователни X1 warps. За максимизиране на оперативната ефективност по време на копаене, данните във всеки файл са организирани по scoop: всички scoop 0 данни от всеки warp се съхраняват последователно, следвани от всички scoop 1 данни и т.н. до scoop 4095.

Това **scoop-последователно подреждане** позволява на миньорите да четат пълните данни, необходими за избран scoop, с един последователен достъп до диска, минимизирайки времената за търсене и максимизирайки пропускателната способност на масови устройства за съхранение.

Комбинирано с XOR-transpose кодирането от Раздел 3.3, този формат гарантира, че файлът е едновременно **структурно закален** и **оперативно ефективен**: последователното подреждане на scoops поддържа оптимален дисков I/O, докато SIMD-подравнените формати в паметта (вижте Раздел 3.2) позволяват високопроизводително, паралелизирано оценяване на scoop.

### 3.5 Proof-of-Work мащабиране (Xn)

PoCX имплементира мащабируемо предварително изчисление чрез концепцията за нива на мащабиране, обозначени Xn, за адаптиране към развиващата се производителност на хардуера. Базовият X1 формат представлява първата XOR-transpose закалена warp структура.

Всяко ниво на мащабиране Xn увеличава proof-of-work, вграден във всеки warp, експоненциално спрямо X1: работата, необходима на ниво Xn, е 2^(n-1) пъти тази на X1. Преходът от Xn към Xn+1 е оперативно еквивалентен на прилагане на XOR през двойки съседни warps, постепенно вграждайки повече proof-of-work без промяна на подлежащия размер на plot.

Съществуващи plot файлове, създадени на по-ниски нива на мащабиране, все още могат да се използват за копаене, но те допринасят пропорционално по-малко работа към генериране на блок, отразявайки техния по-нисък вграден proof-of-work. Този механизъм гарантира, че PoCX plots остават сигурни, гъвкави и икономически балансирани с времето.

### 3.6 Функционалност на Seed

Параметърът seed позволява множество непрепокриващи се plots за адрес без ръчна координация.

**Проблем (POC2)**: Миньорите трябваше ръчно да проследяват диапазони на nonces през plot файлове, за да избегнат припокриване. Припокриващите се nonces разхищават съхранение без увеличаване на силата за копаене.

**Решение**: Всяка двойка `(address, seed)` дефинира независимо ключово пространство. Plots с различни seeds никога не се припокриват, независимо от диапазоните на nonces. Миньорите могат да създават plots свободно без координация.

---

## 4. Proof of Capacity консенсус

PoCX разширява Nakamoto консенсуса на Bitcoin с механизъм за доказателство, ограничен от съхранение. Вместо да изразходват енергия за повторно хеширане, миньорите ангажират големи количества предварително изчислени данни — plots — на диск. По време на генериране на блок те трябва да локализират малка, непредвидима част от тези данни и да я трансформират в доказателство. Миньорът, който предостави най-доброто доказателство в очаквания времеви прозорец, печели правото да подпише следващия блок.

Тази глава описва как PoCX структурира метаданните на блока, извлича непредвидимост и трансформира статичното съхранение в сигурен консенсусен механизъм с ниска вариация.

### 4.1 Структура на блок

PoCX запазва познатото заглавие на блок в стил Bitcoin, но въвежда допълнителни консенсусни полета, необходими за базирано на капацитет копаене. Тези полета колективно свързват блока със съхранения plot на миньора, трудността на мрежата и криптографската ентропия, която дефинира всяко предизвикателство за копаене.

На високо ниво PoCX блокът съдържа: височината на блока, записана явно за опростяване на контекстуалната валидация; генерационния подпис, източник на свежа ентропия, свързващ всеки блок с предшественика му; базовата цел, представляваща мрежовата трудност в обратна форма (по-високи стойности съответстват на по-лесно копаене); PoCX доказателството, идентифициращо plot на миньора, нивото на компресия, използвано по време на plotting, избрания nonce и извлеченото качество; и ключ за подпис и подпис, доказващ контрол над капацитета, използван за подписване на блока (или на делегиран ключ за подписване).

Доказателството вгражда цялата консенсусно релевантна информация, необходима на валидаторите за преизчисляване на предизвикателството, верифициране на избрания scoop и потвърждаване на резултантното качество. Чрез разширяване, а не редизайн на структурата на блока, PoCX остава концептуално съгласуван с Bitcoin, като същевременно позволява фундаментално различен източник на работа за копаене.

### 4.2 Верига на генерационни подписи

Генерационният подпис предоставя непредвидимостта, необходима за сигурно Proof of Capacity копаене. Всеки блок извлича своя генерационен подпис от подписа и подписващия на предишния блок, гарантирайки че миньорите не могат да предвидят бъдещи предизвикателства или предварително да изчислят изгодни региони на plot:

`generationSignature[n] = SHA256(generationSignature[n-1] || miner_pubkey[n-1])`

Това произвежда поредица от криптографски силни, зависими от миньора стойности на ентропия. Тъй като публичният ключ на миньора е неизвестен докато предишният блок не бъде публикуван, никой участник не може да предвиди бъдещи избори на scoop. Това предотвратява селективно предварително изчисление или стратегическо plotting и гарантира, че всеки блок въвежда истински нова работа за копаене.

### 4.3 Процес на подписване

Копаенето в PoCX се състои от трансформиране на съхранени данни в доказателство, управлявано изцяло от генерационния подпис. Въпреки че процесът е детерминистичен, непредвидимостта на подписа гарантира, че миньорите не могат да се подготвят предварително и трябва многократно да достъпват своите съхранени plots.

**Извличане на предизвикателство (избор на Scoop):** Миньорът хешира текущия генерационен подпис с височината на блока за получаване на scoop индекс в диапазона 0–4095. Този индекс определя кой 64-байтов сегмент от всеки съхранен nonce участва в доказателството. Тъй като генерационният подпис зависи от подписващия на предишния блок, изборът на scoop става известен само в момента на публикуване на блока.

**Оценка на доказателство (изчисляване на качество):** За всеки nonce в plot, миньорът извлича избрания scoop и го хешира заедно с генерационния подпис за получаване на качество — 64-битова стойност, чиято величина определя конкурентоспособността на миньора. По-ниско качество съответства на по-добро доказателство.

**Формиране на краен срок (Time Bending):** Суровият краен срок е пропорционален на качеството и обратно пропорционален на базовата цел. В наследени PoC дизайни тези крайни срокове следват силно изкривено експоненциално разпределение, произвеждайки дълги опашки от забавяния, които не осигуряват допълнителна сигурност. PoCX трансформира суровия краен срок, използвайки Time Bending (Раздел 4.4), намалявайки вариацията и осигурявайки предсказуеми интервали между блоковете. Когато огънатият краен срок изтече, миньорът подписва блок чрез вграждане на доказателството и подписването му с ефективния ключ за подписване.

### 4.4 Time Bending

Proof of Capacity произвежда експоненциално разпределени крайни срокове. След кратък период — обикновено няколко десетки секунди — всеки миньор вече е идентифицирал най-доброто си доказателство и всяко допълнително време за изчакване допринася само латентност, не сигурност.

Time Bending преоформя разпределението чрез прилагане на трансформация с кубичен корен:

`deadline_bended = scale × (quality / base_target)^(1/3)`

Факторът за мащабиране запазва очакваното време на блок (120 секунди), като същевременно драматично намалява вариацията. Кратките крайни срокове се разширяват, подобрявайки разпространението на блокове и мрежовата безопасност. Дългите крайни срокове се компресират, предотвратявайки аутлайери да забавят веригата.

![Разпределения на време на блок](blocktime_distributions.svg)

Time Bending поддържа информационното съдържание на подлежащото доказателство. То не модифицира конкурентоспособността между миньорите; само преразпределя времето за изчакване за получаване на по-гладки, по-предсказуеми интервали между блоковете. Имплементацията използва аритметика с фиксирана точка (Q42 формат) и 256-битови цели числа за осигуряване на детерминистични резултати на всички платформи.

### 4.5 Корекция на трудност

PoCX регулира производството на блокове, използвайки базовата цел, обратна мярка за трудност. Очакваното време на блок е пропорционално на съотношението `quality / base_target`, така че увеличаването на базовата цел ускорява създаването на блокове, докато намаляването й забавя веригата.

Трудността се коригира на всеки блок, използвайки измереното време между последните блокове в сравнение с целевия интервал. Тази честа корекция е необходима, защото капацитетът за съхранение може да се добавя или премахва бързо — за разлика от хеш мощността на Bitcoin, която се променя по-бавно.

Корекцията следва две водещи ограничения: **Постепенност** — промените за блок са ограничени (±20% максимум) за избягване на осцилации или манипулация; **Закаляване** — базовата цел не може да надвиши стойността си от генезиса, предотвратявайки мрежата някога да понижи трудността под оригиналните предположения за сигурност.

### 4.6 Валидност на блок

Блок в PoCX е валиден, когато представя верифицируемо доказателство, извлечено от съхранение, съгласувано с консенсусното състояние. Валидаторите независимо преизчисляват избора на scoop, извличат очакваното качество от подадения nonce и метаданни на plot, прилагат трансформацията Time Bending и потвърждават, че миньорът е имал право да подпише блока в декларираното време.

Конкретно валиден блок изисква: крайният срок да е изтекъл от родителския блок; подаденото качество да съвпада с изчисленото качество за доказателството; нивото на мащабиране да отговаря на минимума на мрежата; генерационният подпис да съвпада с очакваната стойност; базовата цел да съвпада с очакваната стойност; подписът на блока да идва от ефективния подписващ; и coinbase да плаща на адреса на ефективния подписващ.

---

## 5. Делегирания за подписване

### 5.1 Мотивация

Делегиранията за подписване позволяват на собствениците на plot да делегират правомощия за подписване на блок, без никога да се отказват от собствеността върху своите plots. Този механизъм позволява копаене в пул и настройки за студено съхранение, като същевременно запазва гаранциите за сигурност на PoCX.

При копаене в пул собствениците на plot могат да упълномощят пул да подписва блокове от тяхно име. Пулът сглобява блокове и разпределя награди, но никога не получава попечителство над самите plots. Делегирането е обратимо по всяко време и собствениците на plot остават свободни да напуснат пул или да променят конфигурации без reploting.

Делегиранията също поддържат чисто разделение между студени и горещи ключове. Частният ключ, контролиращ plot, може да остане офлайн, докато отделен ключ за подписване — съхранен на онлайн машина — произвежда блокове. Компрометиране на ключа за подписване следователно компрометира само правомощията за подписване, не собствеността. Plot-ът остава в безопасност и делегирането може да бъде отменено, затваряйки пробива в сигурността незабавно.

Делегиранията за подписване по този начин осигуряват оперативна гъвкавост, като същевременно поддържат принципа, че контролът над съхранения капацитет никога не трябва да се прехвърля на посредници.

### 5.2 Протокол за делегиране

Делегиранията се декларират чрез OP_RETURN транзакции, за да се избегне ненужно нарастване на UTXO сета. Транзакция за делегиране указва адреса на plot и адреса за подписване, който е упълномощен да произвежда блокове, използвайки капацитета на този plot. Транзакция за отмяна съдържа само адреса на plot. И в двата случая собственикът на plot доказва контрол чрез подписване на харчещия вход на транзакцията.

Всяко делегиране преминава през поредица от добре дефинирани състояния (UNASSIGNED, ASSIGNING, ASSIGNED, REVOKING, REVOKED). След като транзакция за делегиране се потвърди, системата навлиза в кратка фаза на активиране. Това забавяне — 30 блока, приблизително един час — осигурява стабилност по време на надпревари за блокове и предотвратява враждебно бързо превключване на идентичности за подписване. След като този период на активиране изтече, делегирането става активно и остава такова докато собственикът на plot не издаде отмяна.

Отмяните преминават в по-дълъг период на забавяне от 720 блока, приблизително един ден. През това време предишният адрес за подписване остава активен. Това по-дълго забавяне осигурява оперативна стабилност за пулове, предотвратявайки стратегическо "прескачане на делегирания" и давайки на доставчиците на инфраструктура достатъчна сигурност за ефективна работа. След изтичане на забавянето на отмяната, отмяната завършва и собственикът на plot е свободен да определи нов ключ за подписване.

Състоянието на делегиране се поддържа в структура на консенсусния слой, паралелна на UTXO сета, и поддържа undo данни за безопасно обработване на реорганизации на веригата.

### 5.3 Правила за валидация

За всеки блок валидаторите определят ефективния подписващ — адреса, който трябва да подпише блока и да получи coinbase наградата. Този подписващ зависи единствено от състоянието на делегиране при височината на блока.

Ако не съществува делегиране или делегирането още не е завършило фазата си на активиране, собственикът на plot остава ефективен подписващ. Когато делегирането стане активно, назначеният адрес за подписване трябва да подпише. По време на отмяна адресът за подписване продължава да подписва докато забавянето на отмяната не изтече. Едва тогава правомощията се връщат на собственика на plot.

Валидаторите прилагат, че подписът на блока е произведен от ефективния подписващ, че coinbase плаща на същия адрес и че всички преходи следват предписаните забавяния за активиране и отмяна. Само собственикът на plot може да създава или отменя делегирания; ключовете за подписване не могат да модифицират или разширяват собствените си разрешения.

Делегиранията за подписване следователно въвеждат гъвкаво делегиране без въвеждане на доверие. Собствеността върху подлежащия капацитет винаги остава криптографски закотвена към собственика на plot, докато правомощията за подписване могат да се делегират, ротират или отменят според оперативните нужди.

---

## 6. Динамично мащабиране

С еволюирането на хардуера, разходите за изчисляване на plots намаляват спрямо четенето на предварително изчислена работа от диска. Без контрамерки атакуващите биха могли в крайна сметка да генерират доказателства в движение по-бързо от миньорите, четящи съхранена работа, подкопавайки модела на сигурност на Proof of Capacity.

За запазване на предвидения марж на сигурност, PoCX имплементира график за мащабиране: минималното необходимо ниво на мащабиране за plots се увеличава с времето. Всяко ниво на мащабиране Xn, както е описано в Раздел 3.5, вгражда експоненциално повече proof-of-work в структурата на plot, гарантирайки че миньорите продължават да ангажират значителни ресурси за съхранение дори когато изчислението става по-евтино.

Графикът се съгласува с икономическите стимули на мрежата, особено halvings на награди за блок. С намаляването на наградата за блок, минималното ниво постепенно се увеличава, запазвайки баланса между усилие за plotting и потенциал за копаене:

| Период | Години | Halvings | Мин. мащабиране | Множител на работа за Plot |
|--------|--------|----------|-----------------|----------------------------|
| Епоха 0 | 0-4 | 0 | X1 | 2× базова линия |
| Епоха 1 | 4-12 | 1-2 | X2 | 4× базова линия |
| Епоха 2 | 12-28 | 3-6 | X3 | 8× базова линия |
| Епоха 3 | 28-60 | 7-14 | X4 | 16× базова линия |
| Епоха 4 | 60-124 | 15-30 | X5 | 32× базова линия |
| Епоха 5 | 124+ | 31+ | X6 | 64× базова линия |

Миньорите могат по избор да подготвят plots, надвишаващи текущия минимум с едно ниво, позволявайки им да планират напред и да избегнат незабавни надграждания, когато мрежата премине към следващата епоха. Тази незадължителна стъпка не дава допълнително предимство по отношение на вероятност за блок — тя просто позволява по-плавен оперативен преход.

Блокове, съдържащи доказателства под минималното ниво на мащабиране за тяхната височина, се считат за невалидни. Валидаторите проверяват декларираното ниво на мащабиране в доказателството спрямо текущото изискване на мрежата по време на консенсусна валидация, гарантирайки че всички участващи миньори отговарят на развиващите се очаквания за сигурност.

---

## 7. Архитектура на копаене

PoCX разделя консенсусно критичните операции от ресурсоемките задачи на копаене, позволявайки както сигурност, така и ефективност. Възелът поддържа блокчейна, валидира блокове, управлява mempool и излага RPC интерфейс. Външните миньори обработват съхранение на plot, четене на scoop, изчисляване на качество и управление на крайни срокове. Това разделение запазва консенсусната логика проста и одитируема, като същевременно позволява на миньорите да оптимизират за дискова пропускателна способност.

### 7.1 RPC интерфейс за копаене

Миньорите взаимодействат с възела чрез минимален набор от RPC извиквания. get_mining_info RPC предоставя текущата височина на блок, генерационен подпис, базова цел, целеви краен срок и приемливия диапазон от нива на мащабиране на plot. Използвайки тази информация, миньорите изчисляват кандидат nonces. submit_nonce RPC позволява на миньорите да подават предложено решение, включително идентификатор на plot, индекс на nonce, ниво на мащабиране и акаунт на миньор. Възелът оценява подаването и отговаря с изчисления краен срок, ако доказателството е валидно.

### 7.2 Планировчик за подписване

Възелът поддържа планировчик за подписване, който проследява входящи подавания и запазва само най-доброто решение за всяка височина на блок. Подадените nonces се поставят на опашка с вградени защити срещу flooding на подавания или denial-of-service атаки. Планировчикът изчаква докато изчисленият краен срок изтече или пристигне превъзходно решение, при което сглобява блок, подписва го с ефективния ключ за подписване и го публикува в мрежата.

### 7.3 Защитно подписване

За предотвратяване на атаки с времето или стимули за манипулация на часовника, PoCX имплементира защитно подписване. Ако конкурентен блок пристигне за същата височина, планировчикът сравнява локалното решение с новия блок. Ако локалното качество е превъзходно, възелът подписва незабавно, а не чака за оригиналния краен срок. Това гарантира, че миньорите не могат да спечелят предимство просто чрез коригиране на локални часовници; най-доброто решение винаги побеждава, запазвайки справедливост и мрежова сигурност.

---

## 8. Анализ на сигурността

### 8.1 Модел на заплахи

PoCX моделира противници със значителни, но ограничени способности. Атакуващите могат да опитат да претоварят мрежата с невалидни транзакции, некоректни блокове или фалшифицирани доказателства, за да стрес-тестват пътищата на валидация. Те могат свободно да манипулират своите локални часовници и могат да опитат да експлоатират гранични случаи в консенсусното поведение като обработка на времеви марки, динамика на корекция на трудност или правила за реорганизация. Също се очаква противниците да търсят възможности за пренаписване на история чрез целеви разклонения на веригата.

Моделът предполага, че никоя отделна страна не контролира мнозинство от общия капацитет за съхранение на мрежата. Както при всеки консенсусен механизъм, базиран на ресурси, 51% атакуващ с капацитет може едностранно да реорганизира веригата; това фундаментално ограничение не е специфично за PoCX. PoCX също предполага, че атакуващите не могат да изчисляват plot данни по-бързо от честните миньори, които ги четат от диск. Графикът за мащабиране (Раздел 6) гарантира, че изчислителната разлика, необходима за сигурност, нараства с времето при подобряване на хардуера.

Следващите раздели разглеждат всеки основен клас атаки в детайли и описват контрамерките, вградени в PoCX.

### 8.2 Атаки с капацитет

Подобно на PoW, атакуващ с мажоритарен капацитет може да пренапише история (51% атака). Постигането на това изисква придобиване на физически отпечатък за съхранение, по-голям от честната мрежа — скъпо и логистично взискателно начинание. След като хардуерът бъде придобит, оперативните разходи са ниски, но първоначалната инвестиция създава силен икономически стимул за честно поведение: подкопаването на веригата би увредило стойността на собствената активна база на атакуващия.

PoC също избягва проблема nothing-at-stake, свързан с PoS. Въпреки че миньорите могат да сканират plots срещу множество конкуриращи се разклонения, всяко сканиране консумира реално време — обикновено от порядъка на десетки секунди за верига. С 120-секунден интервал между блоковете, това по своята същност ограничава копаенето на множество разклонения и опитът за копаене на много разклонения едновременно влошава производителността на всички тях. Копаенето на разклонения следователно не е безплатно; то е фундаментално ограничено от I/O пропускателната способност.

Дори ако бъдещ хардуер позволи почти мигновено сканиране на plot (напр. високоскоростни SSD), атакуващият все пак би се сблъскал със значително изискване за физически ресурси, за да контролира мнозинство от мрежовия капацитет, правейки атака в стил 51% скъпа и логистично предизвикателна.

Накрая атаките с капацитет са много по-трудни за наемане от атаките с хеш мощност. GPU изчисление може да се придобие при поискване и да се пренасочи към всяка PoW верига мигновено. За разлика от това PoC изисква физически хардуер, времеемко plotting и непрекъснати I/O операции. Тези ограничения правят краткосрочните, опортюнистични атаки много по-малко осъществими.

### 8.3 Атаки с време

Времето играе по-критична роля в Proof of Capacity, отколкото в Proof of Work. В PoW времевите марки предимно влияят на корекцията на трудност; в PoC те определят дали крайният срок на миньора е изтекъл и следователно дали блокът е допустим за подписване. Крайните срокове се измерват спрямо времевата марка на родителския блок, но локалният часовник на възела се използва за преценка дали входящ блок лежи твърде далеч в бъдещето. По тази причина PoCX налага строг толеранс за времева марка: блокове не могат да се отклоняват повече от 15 секунди от локалния часовник на възела (в сравнение с 2-часовия прозорец на Bitcoin). Този лимит работи и в двете посоки — блокове твърде далеч в бъдещето се отхвърлят и възли с бавни часовници могат неправилно да отхвърлят валидни входящи блокове.

Възлите следователно трябва да синхронизират своите часовници, използвайки NTP или еквивалентен източник на време. PoCX умишлено избягва да разчита на вътрешно-мрежови източници на време, за да предотврати атакуващи да манипулират възприеманото мрежово време. Възлите следят собственото си отклонение и издават предупреждения, ако локалният часовник започне да се отклонява от последните времеви марки на блокове.

Ускоряване на часовника — работа с бърз локален часовник за подписване малко по-рано — осигурява само маргинална полза. В рамките на позволения толеранс защитното подписване (Раздел 7.3) гарантира, че миньор с по-добро решение ще публикува незабавно при виждане на по-лош ранен блок. Бързият часовник помага на миньора да публикува вече печелившо решение няколко секунди по-рано; той не може да превърне по-лошо доказателство в печелившо.

Опитите за манипулиране на трудност чрез времеви марки са ограничени от ±20% корекция за блок и 24-блоков плаващ прозорец, предотвратявайки миньорите от смислено влияние на трудността чрез краткосрочни игри с времето.

### 8.4 Атаки с компромис време-памет

Компромисите време-памет се опитват да намалят изискванията за съхранение чрез преизчисляване на части от plot при поискване. Предишни Proof of Capacity системи бяха уязвими на такива атаки, най-вече дефекта в дисбаланса на scoop в POC1 и атаката с XOR-transpose компресия в POC2 (Раздел 2.4). И двете експлоатираха асиметрии в това колко скъпо беше да се регенерират определени части от plot данни, позволявайки на противници да намалят съхранението, като плащат само малка изчислителна санкция. Също така алтернативни формати на plot към PoC2 страдат от подобни слабости на TMTO; видин пример е Chia, чийто формат на plot може да бъде произволно намален с фактор по-голям от 4.

PoCX премахва напълно тези атакни повърхности чрез своята конструкция на nonce и warp формат. В рамките на всеки nonce финалната стъпка на дифузия хешира напълно изчисления буфер и XOR-ва резултата през всички байтове, гарантирайки че всяка част от буфера зависи от всяка друга част и не може да бъде съкратена. След това POC2 размесването разменя долните и горните половини на всеки scoop, изравнявайки изчислителните разходи за възстановяване на всеки scoop.

PoCX допълнително елиминира атаката с XOR-transpose компресия на POC2 чрез извличане на своя закален X1 формат, където всеки scoop е XOR на директна и транспонирана позиция през сдвоени warps; това свързва всеки scoop с цял ред и цяла колона от подлежащите X0 данни, правейки реконструкцията да изисква хиляди пълни nonces и по този начин премахвайки асиметричния компромис време-памет изцяло.

В резултат съхраняването на пълния plot е единствената изчислително жизнеспособна стратегия за миньорите. Няма известен shortcut — независимо дали частично plotting, селективно регенериране, структурирана компресия или хибридни подходи compute-storage — осигурява смислено предимство. PoCX гарантира, че копаенето остава строго ограничено от съхранение и че капацитетът отразява реален, физически ангажимент.

### 8.5 Атаки с делегиране

PoCX използва детерминистична машина на състоянията за управление на всички делегирания от plot към подписващ. Всяко делегиране преминава през добре дефинирани състояния — UNASSIGNED → ASSIGNING → ASSIGNED → REVOKING → REVOKED — с наложени забавяния за активиране и отмяна. Това гарантира, че миньор не може мигновено да променя делегирания, за да мами системата или бързо да превключва правомощия за подписване.

Тъй като всички преходи изискват криптографски доказателства — конкретно подписи от собственика на plot, които са верифицируеми срещу входния UTXO — мрежата може да се довери на легитимността на всяко делегиране. Опитите за заобикаляне на машината на състоянията или фалшифициране на делегирания автоматично се отхвърлят по време на консенсусна валидация. Replay атаките също се предотвратяват от стандартни Bitcoin-стил защити срещу replay на транзакции, гарантирайки че всяко действие за делегиране е уникално обвързано с валиден, неизразходван вход.

Комбинацията от управление на машина на състоянията, наложени забавяния и криптографско доказателство прави измамата, базирана на делегиране, практически невъзможна: миньорите не могат да отвлекат делегирания, да извършват бързо пределегиране по време на надпревари за блокове или да заобиколят графици за отмяна.

### 8.6 Сигурност на подписи

Подписите на блокове в PoCX служат като критична връзка между доказателство и ефективния ключ за подписване, гарантирайки че само упълномощени миньори могат да произвеждат валидни блокове.

За предотвратяване на атаки с податливост, подписите са изключени от изчислението на хеша на блока. Това елиминира рискове от податливи подписи, които биха могли да подкопаят валидацията или да позволят атаки за замяна на блок.

За смекчаване на denial-of-service вектори, размерите на подпис и публичен ключ са фиксирани — 65 байта за компактни подписи и 33 байта за компресирани публични ключове — предотвратявайки атакуващите да раздуват блокове, за да предизвикат изчерпване на ресурси или забавяне на мрежовото разпространение.

---

## 9. Имплементация

PoCX е имплементиран като модулно разширение на Bitcoin Core, с целия релевантен код, съдържащ се в собствена специална поддиректория и активиран чрез feature flag. Този дизайн запазва целостта на оригиналния код, позволявайки PoCX да се активира или деактивира чисто, което опростява тестването, одита и поддържането в синхрон с upstream промени.

Интеграцията засяга само съществените точки, необходими за поддържане на Proof of Capacity. Заглавието на блока е разширено да включва PoCX-специфични полета и консенсусната валидация е адаптирана да обработва доказателства, базирани на съхранение, наред със стандартните Bitcoin проверки. Системата за подписване, отговорна за управление на крайни срокове, планиране и подавания от миньори, е напълно съдържана в PoCX модулите, докато RPC разширенията излагат функционалност за копаене и делегиране на външни клиенти. За потребителите интерфейсът на портфейла е подобрен да управлява делегирания чрез OP_RETURN транзакции, позволявайки безпроблемно взаимодействие с новите консенсусни функции.

Всички консенсусно критични операции са имплементирани в детерминистичен C++ без външни зависимости, гарантирайки кросплатформена консистентност. Shabal256 се използва за хеширане, докато Time Bending и изчисляване на качество разчитат на аритметика с фиксирана точка и 256-битови операции. Криптографски операции като верификация на подпис използват съществуващата библиотека secp256k1 на Bitcoin Core.

Чрез изолиране на функционалността на PoCX по този начин, имплементацията остава одитируема, поддържаема и напълно съвместима с продължаващото развитие на Bitcoin Core, демонстрирайки че фундаментално нов консенсусен механизъм, ограничен от съхранение, може да съществува съвместно с зряла proof-of-work кодова база, без да нарушава нейната цялост или използваемост.

---

## 10. Мрежови параметри

PoCX надгражда върху мрежовата инфраструктура на Bitcoin и използва повторно рамката за параметри на веригата. За поддържане на базирано на капацитет копаене, интервали между блоковете, обработка на делегирания и мащабиране на plot, няколко параметъра са разширени или пренаписани. Това включва целевото време на блок, първоначална субсидия, график за halving, забавяния за активиране и отмяна на делегиране, както и мрежови идентификатори като magic байтове, портове и Bech32 префикси. Testnet и regtest средите допълнително коригират тези параметри, за да позволят бърза итерация и тестване с нисък капацитет.

Таблиците по-долу обобщават резултантните настройки за mainnet, testnet и regtest, подчертавайки как PoCX адаптира основните параметри на Bitcoin към консенсусен модел, ограничен от съхранение.

### 10.1 Mainnet

| Параметър | Стойност |
|-----------|----------|
| Magic байтове | `0xa7 0x3c 0x91 0x5e` |
| Порт по подразбиране | 8888 |
| Bech32 HRP | `pocx` |
| Целево време на блок | 120 секунди |
| Първоначална субсидия | 10 BTC |
| Интервал на halving | 1050000 блока (~4 години) |
| Общо предлагане | ~21 милиона BTC |
| Активиране на делегиране | 30 блока |
| Отмяна на делегиране | 720 блока |
| Плаващ прозорец | 24 блока |

### 10.2 Testnet

| Параметър | Стойност |
|-----------|----------|
| Magic байтове | `0x6d 0xf2 0x48 0xb3` |
| Порт по подразбиране | 18888 |
| Bech32 HRP | `tpocx` |
| Целево време на блок | 120 секунди |
| Други параметри | Същите като mainnet |

### 10.3 Regtest

| Параметър | Стойност |
|-----------|----------|
| Magic байтове | `0xfa 0xbf 0xb5 0xda` |
| Порт по подразбиране | 18444 |
| Bech32 HRP | `rpocx` |
| Целево време на блок | 1 секунда |
| Интервал на halving | 500 блока |
| Активиране на делегиране | 4 блока |
| Отмяна на делегиране | 8 блока |
| Режим с нисък капацитет | Активиран (~4 MB plots) |

---

## 11. Свързани работи

През годините няколко блокчейн и консенсусни проекти са изследвали модели за копаене, базирани на съхранение или хибридни. PoCX надгражда върху тази линия, като същевременно въвежда подобрения в сигурността, ефективността и съвместимостта.

**Burstcoin / Signum.** Burstcoin въведе първата практична Proof-of-Capacity (PoC) система през 2014, дефинирайки основни концепции като plots, nonces, scoops и копаене, базирано на крайни срокове. Наследниците му, по-специално Signum (бивш Burstcoin), разшириха екосистемата и в крайна сметка еволюираха в това, което е известно като Proof-of-Commitment (PoC+), комбинирайки ангажимент за съхранение с незадължително staking за влияние на ефективния капацитет. PoCX наследява основата за копаене, базирано на съхранение, от тези проекти, но се различава значително чрез закален формат на plot (XOR-transpose кодиране), динамично мащабиране на работа за plot, изглаждане на крайни срокове ("Time Bending") и гъвкава система за делегиране — всичко това, като се закотвя в кодовата база на Bitcoin Core, а не поддържа самостоятелен мрежов fork.

**Chia.** Chia имплементира Proof of Space and Time, комбинирайки дискови доказателства за съхранение с времеви компонент, налаган чрез Verifiable Delay Functions (VDFs). Нейният дизайн адресира определени притеснения относно повторно използване на доказателства и генериране на свежи предизвикателства, различни от класическия PoC. PoCX не възприема този модел на доказателство, закотвен във времето; вместо това поддържа консенсус, ограничен от съхранение, с предсказуеми интервали, оптимизиран за дългосрочна съвместимост с UTXO икономика и инструменти, извлечени от Bitcoin.

**Spacemesh.** Spacemesh предлага Proof-of-Space-Time (PoST) схема, използваща DAG-базирана (mesh) мрежова топология. В този модел участниците трябва периодично да доказват, че разпределеното съхранение остава непокътнато с времето, а не да разчитат на единичен предварително изчислен набор от данни. PoCX, за разлика от това, верифицира ангажимента за съхранение само по време на блок — със закалени формати на plot и стриктна валидация на доказателства — избягвайки overhead-а на непрекъснати доказателства за съхранение, като същевременно запазва ефективност и децентрализация.

---

## 12. Заключение

Bitcoin-PoCX демонстрира, че енергийно ефективен консенсус може да бъде интегриран в Bitcoin Core, като същевременно запазва свойствата на сигурност и икономическия модел. Ключовите приноси включват XOR-transpose кодирането (принуждава атакуващите да изчислят 4096 nonces за справка, елиминирайки атаката с компресия), алгоритъма Time Bending (трансформация на разпределение намалява вариацията на времето на блок), системата за делегиране на подписване (базирано на OP_RETURN делегиране позволява некустодиално копаене в пул), динамичното мащабиране (съгласувано с halvings за поддържане на маржове на сигурност) и минималната интеграция (код с feature-flag, изолиран в специализирана директория).

Системата понастоящем е във фаза на тестова мрежа. Силата за копаене се извлича от капацитет за съхранение, а не от хеш мощност, намалявайки консумацията на енергия с порядъци, като същевременно поддържа доказания икономически модел на Bitcoin.

---

## Препратки

Bitcoin Core. *Bitcoin Core Repository.* https://github.com/bitcoin/bitcoin

Burstcoin. *Proof of Capacity Technical Documentation.* 2014.

NIST. *SHA-3 Competition: Shabal.* 2008.

Cohen, B., Pietrzak, K. *The Chia Network Blockchain.* 2019.

Spacemesh. *Spacemesh Protocol Documentation.* 2021.

PoC Consortium. *PoCX Framework.* https://github.com/PoC-Consortium/pocx

PoC Consortium. *Bitcoin-PoCX Integration.* https://github.com/PoC-Consortium/bitcoin-pocx

---

**Лиценз**: MIT
**Организация**: Proof of Capacity Consortium
**Статус**: Фаза на тестова мрежа
