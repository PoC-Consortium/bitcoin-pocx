# Bitcoin-PoCX: קונצנזוס חסכוני באנרגיה עבור Bitcoin Core

**גרסה**: 2.0 טיוטה
**תאריך**: דצמבר 2025
**ארגון**: Proof of Capacity Consortium

---

## תקציר

מנגנון הקונצנזוס Proof-of-Work (PoW) של Bitcoin מספק אבטחה חזקה אך צורך אנרגיה ניכרת בשל חישוב hash בזמן אמת באופן רציף. אנו מציגים את Bitcoin-PoCX, פיצול (fork) של Bitcoin המחליף PoW ב-Proof of Capacity (PoC), שבו כורים מחשבים מראש ומאחסנים קבוצות גדולות של hash-ים המאוחסנים בדיסק במהלך שלב ה-plotting, ולאחר מכן כורים על ידי ביצוע חיפושים קלים במקום hashing מתמשך. על ידי העברת החישוב משלב הכרייה לשלב plotting חד-פעמי, Bitcoin-PoCX מפחית באופן דרמטי את צריכת האנרגיה תוך אפשור כרייה על חומרה סטנדרטית, הורדת מחסום הכניסה והפחתת לחצי הריכוזיות הטבועים ב-PoW הנשלט על ידי ASIC, כל זאת תוך שמירה על הנחות האבטחה וההתנהגות הכלכלית של Bitcoin.

היישום שלנו מציג מספר חידושים מרכזיים:
(1) פורמט plot מוקשח המבטל את כל התקפות time-memory-tradeoff הידועות במערכות PoC קיימות, ומבטיח שכוח כרייה יעיל יישאר פרופורציונלי באופן מוחלט לקיבולת האחסון המחויבת;
(2) אלגוריתם Time-Bending, המשנה את התפלגות ה-deadline מאקספוננציאלית ל-chi-squared, מפחית שונות בזמני בלוקים מבלי לשנות את הממוצע;
(3) מנגנון forging-assignment מבוסס OP_RETURN המאפשר כריית pool ללא משמורת; וכן
(4) קנה מידה דחיסה דינמי, המגביר את קושי יצירת ה-plot בהתאמה ללוחות הזמנים של halving כדי לשמור על מרווחי אבטחה ארוכי טווח ככל שהחומרה משתפרת.

Bitcoin-PoCX שומר על הארכיטקטורה של Bitcoin Core באמצעות שינויים מינימליים מבוססי feature-flag, המבודדים את לוגיקת PoC מקוד הקונצנזוס הקיים. המערכת משמרת את המדיניות המוניטרית של Bitcoin על ידי התמקדות במרווח בלוקים של 120 שניות והתאמת סובסידיית הבלוק ל-10 BTC. הסובסידיה המופחתת מקזזת את העלייה פי חמש בתדירות הבלוקים, שומרת על קצב ההנפקה לטווח ארוך בהתאמה ללוח הזמנים המקורי של Bitcoin ומשמרת את ההיצע המקסימלי של כ-21 מיליון.

---

## 1. מבוא

### 1.1 מוטיבציה

מנגנון הקונצנזוס Proof-of-Work (PoW) של Bitcoin הוכיח עצמו כמאובטח במשך יותר מעשור, אך במחיר משמעותי: כורים חייבים להוציא משאבי חישוב באופן רציף, מה שמביא לצריכת אנרגיה גבוהה. מעבר לשיקולי יעילות, קיימת מוטיבציה רחבה יותר: חקירת מנגנוני קונצנזוס חלופיים השומרים על אבטחה תוך הורדת מחסום ההשתתפות. PoC מאפשר כמעט לכל אחד עם חומרת אחסון סטנדרטית לכרות ביעילות, מפחית את לחצי הריכוזיות הנראים בכריית PoW הנשלטת על ידי ASIC.

Proof of Capacity (PoC) משיג זאת על ידי גזירת כוח כרייה ממחויבות לאחסון במקום מחישוב מתמשך. כורים מחשבים מראש קבוצות גדולות של hash-ים המאוחסנים בדיסק - plots - במהלך שלב plotting חד-פעמי. הכרייה מורכבת אז מחיפושים קלים, מפחיתה באופן דרמטי את השימוש באנרגיה תוך שמירה על הנחות האבטחה של קונצנזוס מבוסס משאבים.

### 1.2 שילוב עם Bitcoin Core

Bitcoin-PoCX משלב קונצנזוס PoC לתוך Bitcoin Core במקום ליצור blockchain חדש. גישה זו ממנפת את האבטחה המוכחת של Bitcoin Core, מחסנית הרשת הבשלה שלו, והכלים המאומצים באופן נרחב, תוך שמירה על שינויים מינימליים ומבוססי feature-flag. לוגיקת PoC מבודדת מקוד הקונצנזוס הקיים, ומבטיחה שהפונקציונליות המרכזית - אימות בלוקים, פעולות ארנק, פורמטי עסקאות - נותרת ברובה ללא שינוי.

### 1.3 יעדי עיצוב

**אבטחה**: שמירה על חוסן שווה ערך ל-Bitcoin; התקפות דורשות רוב קיבולת האחסון.

**יעילות**: הפחתת עומס חישובי מתמשך לרמות I/O של דיסק.

**נגישות**: אפשור כרייה עם חומרה סטנדרטית, הורדת מחסומי כניסה.

**שילוב מינימלי**: הצגת קונצנזוס PoC עם טביעת רגל מינימלית של שינויים.

---

## 2. רקע: Proof of Capacity

### 2.1 היסטוריה

Proof of Capacity (PoC) הוצג על ידי Burstcoin ב-2014 כחלופה חסכונית באנרגיה ל-Proof-of-Work (PoW). Burstcoin הדגים שכוח כרייה יכול להיגזר מאחסון מחויב במקום hashing בזמן אמת באופן רציף: כורים חישבו מראש מערכי נתונים גדולים ("plots") פעם אחת ואז כרו על ידי קריאת חלקים קטנים וקבועים מהם.

יישומי PoC מוקדמים הוכיחו שהרעיון ישים אך גם חשפו שפורמט plot ומבנה קריפטוגרפי הם קריטיים לאבטחה. מספר time-memory tradeoffs אפשרו לתוקפים לכרות ביעילות עם פחות אחסון ממשתתפים ישרים. הדבר הדגיש שאבטחת PoC תלויה בעיצוב plot - לא רק בשימוש באחסון כמשאב.

המורשת של Burstcoin ביססה את PoC כמנגנון קונצנזוס מעשי וסיפקה את היסוד עליו PoCX בונה.

### 2.2 מושגים מרכזיים

כריית PoC מבוססת על קבצי plot גדולים מחושבים מראש המאוחסנים בדיסק. plots אלו מכילים "חישוב קפוא": hashing יקר מבוצע פעם אחת במהלך plotting, והכרייה מורכבת אז מקריאות דיסק קלות ואימות פשוט. אלמנטים מרכזיים כוללים:

**Nonce:**
יחידת הנתונים הבסיסית של plot. כל nonce מכיל 4096 scoops (256 KiB בסך הכל) שנוצרו באמצעות Shabal256 מכתובת הכורה ואינדקס ה-nonce.

**Scoop:**
מקטע של 64 בתים בתוך nonce. עבור כל בלוק, הרשת בוחרת באופן דטרמיניסטי אינדקס scoop (0-4095) בהתבסס על generation signature של הבלוק הקודם. רק scoop זה לכל nonce צריך להיקרא.

**Generation Signature:**
ערך של 256 ביט הנגזר מהבלוק הקודם. הוא מספק אנטרופיה לבחירת scoop ומונע מכורים לחזות אינדקסי scoop עתידיים.

**Warp:**
קבוצה מבנית של 4096 nonces (1 GiB). Warps הם היחידה הרלוונטית לפורמטי plot עמידים בפני דחיסה.

### 2.3 תהליך כרייה וצינור איכות

כריית PoC מורכבת משלב plotting חד-פעמי ושגרה קלה לכל בלוק:

**הגדרה חד-פעמית:**
- יצירת plot: חישוב nonces באמצעות Shabal256 וכתיבתם לדיסק.

**כרייה לכל בלוק:**
- בחירת scoop: קביעת אינדקס ה-scoop מה-generation signature.
- סריקת plot: קריאת אותו scoop מכל ה-nonces ב-plots של הכורה.

**צינור איכות:**
- איכות גולמית: hash כל scoop עם ה-generation signature באמצעות Shabal256Lite לקבלת ערך איכות של 64 ביט (נמוך יותר עדיף).
- Deadline: המרת איכות ל-deadline באמצעות base target (פרמטר מותאם קושי המבטיח שהרשת מגיעה למרווח הבלוקים המיועד): `deadline = quality / base_target`
- Bended deadline: החלת טרנספורמציית Time-Bending להפחתת שונות תוך שמירה על זמן בלוק צפוי.

**יציקת בלוק:**
הכורה עם ה-deadline הקצר ביותר (bended) יוצק את הבלוק הבא ברגע שזמן זה חלף.

בניגוד ל-PoW, כמעט כל החישוב מתרחש במהלך plotting; כרייה פעילה היא בעיקר מוגבלת בדיסק וצריכת אנרגיה נמוכה מאוד.

### 2.4 פגיעויות ידועות במערכות קודמות

**פגם התפלגות POC1:**
פורמט POC1 המקורי של Burstcoin הציג הטיה מבנית: scoops עם אינדקס נמוך היו זולים משמעותית לחישוב מחדש בזמן אמת מאשר scoops עם אינדקס גבוה. זה הציג time-memory tradeoff לא אחיד, שאפשר לתוקפים להפחית את האחסון הנדרש עבור אותם scoops ושבר את ההנחה שכל הנתונים המחושבים מראש יקרים באופן שווה.

**התקפת דחיסת XOR (POC2):**
ב-POC2, תוקף יכול לקחת כל קבוצה של 8192 nonces ולחלק אותם לשני בלוקים של 4096 nonces (A ו-B). במקום לאחסן את שני הבלוקים, התוקף מאחסן רק מבנה נגזר: `A ⊕ transpose(B)`, כאשר ה-transpose מחליף בין אינדקסי scoop ו-nonce - scoop S של nonce N בבלוק B הופך ל-scoop N של nonce S.

במהלך כרייה, כאשר נדרש scoop S של nonce N, התוקף משחזר אותו על ידי:
1. קריאת ערך ה-XOR המאוחסן במיקום (S, N)
2. חישוב nonce N מבלוק A לקבלת scoop S
3. חישוב nonce S מבלוק B לקבלת ה-scoop המועבר N
4. XOR של כל שלושת הערכים לשחזור ה-scoop המקורי בן 64 בתים

זה מפחית אחסון ב-50%, תוך דרישה רק לשני חישובי nonce לכל חיפוש - עלות הרבה מתחת לסף הנדרש לאכיפת חישוב מראש מלא. ההתקפה אפשרית כי חישוב שורה (nonce אחד, 4096 scoops) הוא זול, בעוד שחישוב עמודה (scoop יחיד לאורך 4096 nonces) ידרוש התחדשות של כל ה-nonces. מבנה ה-transpose חושף חוסר איזון זה.

זה הדגים את הצורך בפורמט plot המונע שילובים מבניים כאלה ומסיר את ה-time-memory tradeoff הבסיסי. סעיף 3.3 מתאר כיצד PoCX מטפל ופותר חולשה זו.

### 2.5 מעבר ל-PoCX

המגבלות של מערכות PoC מוקדמות הבהירו שכריית אחסון מאובטחת, הוגנת ומבוזרת תלויה במבני plot מהונדסים בקפידה. Bitcoin-PoCX מטפל בבעיות אלו עם פורמט plot מוקשח, התפלגות deadline משופרת, ומנגנונים לכריית pool מבוזרת - המתוארים בסעיף הבא.

---

## 3. פורמט Plot של PoCX

### 3.1 בניית Nonce בסיסית

nonce הוא מבנה נתונים של 256 KiB הנגזר באופן דטרמיניסטי משלושה פרמטרים: payload כתובת בן 20 בתים, seed בן 32 בתים, ואינדקס nonce בן 64 ביט.

הבנייה מתחילה בשילוב קלטים אלו והחלת hash עליהם עם Shabal256 להפקת hash ראשוני. hash זה משמש כנקודת ההתחלה לתהליך הרחבה איטרטיבי: Shabal256 מוחל שוב ושוב, כאשר כל שלב תלוי בנתונים שנוצרו קודם, עד שכל מאגר 256 KiB מתמלא. תהליך משורשר זה מייצג את העבודה החישובית המבוצעת במהלך plotting.

שלב דיפוזיה סופי מחיל hash על המאגר המושלם ומבצע XOR של התוצאה לאורך כל הבתים. זה מבטיח שהמאגר המלא חושב ושכורים לא יכולים לקצר את החישוב. לאחר מכן מוחל ה-shuffle של PoC2, המחליף את החצאים התחתון והעליון של כל scoop כדי להבטיח שכל ה-scoops דורשים מאמץ חישובי שווה ערך.

ה-nonce הסופי מורכב מ-4096 scoops בני 64 בתים כל אחד ומהווה את היחידה הבסיסית המשמשת בכרייה.

### 3.2 פריסת Plot מיושרת ל-SIMD

כדי למקסם תפוקה על חומרה מודרנית, PoCX מארגן נתוני nonce בדיסק כדי להקל על עיבוד וקטורי. במקום לאחסן כל nonce ברצף, PoCX מיישר מילים תואמות בנות 4 בתים לאורך nonces רצופים מרובים באופן רציף. זה מאפשר לשליפת זיכרון בודדת לספק נתונים לכל נתיבי SIMD, ממזער החמצות cache ומבטל תקורת scatter-gather.

```
פריסה מסורתית:
Nonce0: [W0][W1][W2][W3]...
Nonce1: [W0][W1][W2][W3]...
Nonce2: [W0][W1][W2][W3]...

פריסת SIMD של PoCX:
Word0: [N0][N1][N2]...[N15]
Word1: [N0][N1][N2]...[N15]
Word2: [N0][N1][N2]...[N15]
```

פריסה זו מיטיבה גם עם כורי CPU וגם GPU, מאפשרת הערכת scoop מקבילית בתפוקה גבוהה תוך שמירה על דפוס גישה סקלרי פשוט לאימות קונצנזוס. היא מבטיחה שהכרייה מוגבלת על ידי רוחב פס אחסון במקום חישוב CPU, שומרת על האופי הדל-אנרגיה של Proof of Capacity.

### 3.3 מבנה Warp וקידוד XOR-Transpose

warp הוא יחידת האחסון הבסיסית ב-PoCX, המורכב מ-4096 nonces (1 GiB). הפורמט הלא-דחוס, המכונה X0, מכיל nonces בסיסיים בדיוק כפי שהופקו על ידי הבנייה בסעיף 3.1.

**קידוד XOR-Transpose (X1)**

כדי להסיר את ה-time-memory tradeoffs המבניים הקיימים במערכות PoC מוקדמות, PoCX גוזר פורמט כרייה מוקשח, X1, על ידי החלת קידוד XOR-transpose על זוגות של warps מסוג X0.

לבניית scoop S של nonce N ב-warp מסוג X1:

1. קח את scoop S של nonce N מה-warp הראשון מסוג X0 (מיקום ישיר)
2. קח את scoop N של nonce S מה-warp השני מסוג X0 (מיקום מועבר)
3. בצע XOR על שני ערכי 64 הבתים לקבלת ה-scoop מסוג X1

שלב ה-transpose מחליף בין אינדקסי scoop ו-nonce. במונחי מטריצה - כאשר שורות מייצגות scoops ועמודות מייצגות nonces - הוא משלב את האלמנט במיקום (S, N) ב-warp הראשון עם האלמנט ב-(N, S) בשני.

**מדוע זה מבטל את משטח התקפת הדחיסה**

ה-XOR-transpose מקשר כל scoop עם שורה שלמה ועמודה שלמה של נתוני X0 הבסיסיים. שחזור scoop בודד מסוג X1 דורש אפוא גישה לנתונים המשתרעים על כל 4096 אינדקסי scoop. כל ניסיון לחשב נתונים חסרים ידרוש התחדשות של 4096 nonces מלאים, במקום nonce בודד - מסיר את מבנה העלות הא-סימטרי שנוצל על ידי התקפת XOR עבור POC2 (סעיף 2.4).

כתוצאה מכך, אחסון ה-warp המלא מסוג X1 הופך לאסטרטגיה היחידה הכדאית מבחינה חישובית עבור כורים, וסוגר את ה-time-memory tradeoff שנוצל בעיצובים קודמים.

### 3.4 פריסת דיסק

קבצי plot של PoCX מורכבים מ-warps רבים רצופים מסוג X1. כדי למקסם יעילות תפעולית במהלך כרייה, הנתונים בתוך כל קובץ מאורגנים לפי scoop: כל נתוני scoop 0 מכל warp מאוחסנים ברצף, ואחריהם כל נתוני scoop 1, וכן הלאה, עד scoop 4095.

**סדר רציף לפי scoop** זה מאפשר לכורים לקרוא את הנתונים המלאים הנדרשים ל-scoop נבחר בגישת דיסק רציפה בודדת, ממזער זמני חיפוש וממקסם תפוקה בהתקני אחסון סטנדרטיים.

בשילוב עם קידוד ה-XOR-transpose של סעיף 3.3, פריסה זו מבטיחה שהקובץ הוא גם **מוקשח מבנית** וגם **יעיל תפעולית**: סדר scoop רציף תומך ב-I/O דיסק אופטימלי, בעוד פריסות זיכרון מיושרות ל-SIMD (ראה סעיף 3.2) מאפשרות הערכת scoop מקבילית בתפוקה גבוהה.

### 3.5 קנה מידה Proof-of-Work (Xn)

PoCX מיישם חישוב מראש הניתן להרחבה באמצעות הרעיון של רמות קנה מידה, המסומנות Xn, להתאמה לביצועי חומרה מתפתחים. פורמט X1 הבסיסי מייצג את מבנה ה-warp המוקשח הראשון עם XOR-transpose.

כל רמת קנה מידה Xn מגדילה את ה-proof-of-work המוטמע בכל warp באופן אקספוננציאלי ביחס ל-X1: העבודה הנדרשת ברמה Xn היא 2^(n-1) פעמים זו של X1. מעבר מ-Xn ל-Xn+1 שווה ערך תפעולית להחלת XOR על זוגות של warps סמוכים, מטמיע בהדרגה יותר proof-of-work מבלי לשנות את גודל ה-plot הבסיסי.

קבצי plot קיימים שנוצרו ברמות קנה מידה נמוכות עדיין ניתנים לשימוש בכרייה, אך הם תורמים פחות עבודה באופן פרופורציונלי ליצירת בלוקים, משקפים את ה-proof-of-work הנמוך יותר המוטמע בהם. מנגנון זה מבטיח ש-plots של PoCX נשארים מאובטחים, גמישים ומאוזנים כלכלית לאורך זמן.

### 3.6 פונקציונליות Seed

פרמטר ה-seed מאפשר plots מרובים שאינם חופפים לכל כתובת ללא תיאום ידני.

**בעיה (POC2)**: כורים היו צריכים לעקוב ידנית אחר טווחי nonce לאורך קבצי plot כדי למנוע חפיפה. nonces חופפים מבזבזים אחסון מבלי להגדיל כוח כרייה.

**פתרון**: כל זוג `(address, seed)` מגדיר מרחב מפתחות עצמאי. plots עם seeds שונים לעולם אינם חופפים, ללא קשר לטווחי nonce. כורים יכולים ליצור plots בחופשיות ללא תיאום.

---

## 4. קונצנזוס Proof of Capacity

PoCX מרחיב את קונצנזוס Nakamoto של Bitcoin עם מנגנון הוכחה מוגבל-אחסון. במקום להוציא אנרגיה על hashing חוזר, כורים מחויבים לכמויות גדולות של נתונים מחושבים מראש - plots - לדיסק. במהלך יצירת בלוק, הם חייבים לאתר חלק קטן ובלתי צפוי של נתונים אלו ולהפוך אותו להוכחה. הכורה שמספק את ההוכחה הטובה ביותר בתוך חלון הזמן הצפוי זוכה בזכות ליצוק את הבלוק הבא.

פרק זה מתאר כיצד PoCX מבנה מטא-נתונים של בלוק, גוזר אי-צפיות, והופך אחסון סטטי למנגנון קונצנזוס מאובטח עם שונות נמוכה.

### 4.1 מבנה בלוק

PoCX שומר על כותרת בלוק בסגנון Bitcoin המוכר אך מציג שדות קונצנזוס נוספים הנדרשים לכרייה מבוססת קיבולת. שדות אלו ביחד מקשרים את הבלוק ל-plot המאוחסן של הכורה, לקושי הרשת, ולאנטרופיה הקריפטוגרפית המגדירה כל אתגר כרייה.

ברמה גבוהה, בלוק PoCX מכיל: גובה הבלוק, מתועד במפורש לפישוט אימות הקשרי; ה-generation signature, מקור אנטרופיה רעננה המקשר כל בלוק לקודמו; ה-base target, המייצג קושי רשת בצורה הפוכה (ערכים גבוהים יותר מתאימים לכרייה קלה יותר); הוכחת PoCX, המזהה את ה-plot של הכורה, רמת הדחיסה ששימשה בזמן plotting, ה-nonce הנבחר, והאיכות הנגזרת ממנו; ומפתח חתימה וחתימה, המוכיחים שליטה בקיבולת ששימשה ליציקת הבלוק (או של מפתח יציקה מוקצה).

ההוכחה מטמיעה את כל המידע הרלוונטי לקונצנזוס הנדרש על ידי מאמתים לחישוב מחדש של האתגר, אימות ה-scoop הנבחר, ואישור האיכות המתקבלת. על ידי הרחבה במקום עיצוב מחדש של מבנה הבלוק, PoCX נשאר מיושר מושגית עם Bitcoin תוך אפשור מקור עבודת כרייה שונה מהותית.

### 4.2 שרשרת Generation Signature

ה-generation signature מספק את האי-צפיות הנדרשת לכריית Proof of Capacity מאובטחת. כל בלוק גוזר את ה-generation signature שלו מהחתימה והחותם של הבלוק הקודם, מבטיח שכורים לא יכולים לצפות אתגרים עתידיים או לחשב מראש אזורי plot מועדפים:

`generationSignature[n] = SHA256(generationSignature[n-1] || miner_pubkey[n-1])`

זה מייצר רצף של ערכי אנטרופיה חזקים קריפטוגרפית ותלויי-כורה. מכיוון שהמפתח הציבורי של כורה אינו ידוע עד שהבלוק הקודם מתפרסם, אף משתתף לא יכול לחזות בחירות scoop עתידיות. זה מונע חישוב מראש סלקטיבי או plotting אסטרטגי ומבטיח שכל בלוק מציג עבודת כרייה רעננה באמת.

### 4.3 תהליך יציקה

כרייה ב-PoCX מורכבת מהפיכת נתונים מאוחסנים להוכחה מונעת לחלוטין על ידי ה-generation signature. למרות שהתהליך דטרמיניסטי, האי-צפיות של החתימה מבטיחה שכורים לא יכולים להתכונן מראש וחייבים לגשת שוב ושוב ל-plots המאוחסנים שלהם.

**גזירת אתגר (בחירת Scoop):** הכורה מחיל hash על ה-generation signature הנוכחי עם גובה הבלוק לקבלת אינדקס scoop בטווח 0-4095. אינדקס זה קובע איזה מקטע בן 64 בתים של כל nonce מאוחסן משתתף בהוכחה. מכיוון שה-generation signature תלוי בחותם הבלוק הקודם, בחירת scoop נודעת רק ברגע פרסום הבלוק.

**הערכת הוכחה (חישוב איכות):** עבור כל nonce ב-plot, הכורה מאחזר את ה-scoop הנבחר ומחיל עליו hash יחד עם ה-generation signature לקבלת איכות - ערך בן 64 ביט שגודלו קובע את התחרותיות הכורה. איכות נמוכה יותר מתאימה להוכחה טובה יותר.

**יצירת Deadline (כפיפת זמן):** ה-deadline הגולמי פרופורציונלי לאיכות והפוך פרופורציונלי ל-base target. בעיצובי PoC מדור קודם, deadlines אלו עקבו אחר התפלגות אקספוננציאלית מוטה מאוד, ייצרו עיכובי זנב ארוכים שלא סיפקו אבטחה נוספת. PoCX מתמיר את ה-deadline הגולמי באמצעות Time Bending (סעיף 4.4), מפחית שונות ומבטיח מרווחי בלוקים צפויים. ברגע שה-deadline המכופף עובר, הכורה יוצק בלוק על ידי הטמעת ההוכחה וחתימה עליו עם מפתח היציקה האפקטיבי.

### 4.4 כפיפת זמן (Time Bending)

Proof of Capacity מייצר deadlines מפולגים אקספוננציאלית. לאחר תקופה קצרה - בדרך כלל עשרות שניות בודדות - כל כורה כבר זיהה את ההוכחה הטובה ביותר שלו, וכל זמן המתנה נוסף תורם רק עיכוב, לא אבטחה.

Time Bending מעצבת מחדש את ההתפלגות על ידי החלת טרנספורמציית שורש שלישי:

`deadline_bended = scale × (quality / base_target)^(1/3)`

גורם ה-scale משמר את זמן הבלוק הצפוי (120 שניות) תוך הפחתה דרמטית של השונות. deadlines קצרים מורחבים, משפרים התפשטות בלוקים ובטיחות רשת. deadlines ארוכים נדחסים, מונעים מחריגים לעכב את השרשרת.

![התפלגויות זמן בלוק](blocktime_distributions.svg)

Time Bending שומרת על תוכן המידע של ההוכחה הבסיסית. היא אינה משנה תחרותיות בין כורים; היא רק מקצה מחדש זמן המתנה לייצור מרווחי בלוקים חלקים וצפויים יותר. היישום משתמש באריתמטיקה של נקודה קבועה (פורמט Q42) ומספרים שלמים בני 256 ביט להבטחת תוצאות דטרמיניסטיות על כל הפלטפורמות.

### 4.5 התאמת קושי

PoCX מווסת ייצור בלוקים באמצעות ה-base target, מדד קושי הפוך. זמן הבלוק הצפוי פרופורציונלי ליחס `quality / base_target`, כך שהגדלת ה-base target מאיצה יצירת בלוקים בעוד הקטנתו מאטה את השרשרת.

הקושי מותאם בכל בלוק באמצעות הזמן הנמדד בין בלוקים אחרונים בהשוואה למרווח היעד. התאמה תכופה זו הכרחית כי קיבולת אחסון יכולה להתווסף או להיות מוסרת במהירות - בניגוד ל-hashpower של Bitcoin, שמשתנה לאט יותר.

ההתאמה עוקבת אחר שני אילוצים מנחים: **הדרגתיות** - שינויים לכל בלוק מוגבלים (±20% מקסימום) כדי להימנע מתנודות או מניפולציה; **הקשחה** - ה-base target לא יכול לעלות על ערך הג'נסיס שלו, מונע מהרשת לעולם להוריד את הקושי מתחת להנחות האבטחה המקוריות.

### 4.6 תקפות בלוק

בלוק ב-PoCX תקף כאשר הוא מציג הוכחה ניתנת לאימות הנגזרת מאחסון ועקבית עם מצב הקונצנזוס. מאמתים מחשבים מחדש באופן עצמאי את בחירת ה-scoop, גוזרים את האיכות הצפויה מה-nonce ומטא-נתוני ה-plot שהוגשו, מחילים את טרנספורמציית Time Bending, ומאשרים שהכורה היה זכאי ליצוק את הבלוק בזמן המוצהר.

במפורש, בלוק תקף דורש: ה-deadline עבר מאז בלוק האב; האיכות שהוגשה תואמת לאיכות המחושבת עבור ההוכחה; רמת קנה המידה עומדת במינימום הרשת; ה-generation signature תואם לערך הצפוי; ה-base target תואם לערך הצפוי; חתימת הבלוק מגיעה מהחותם האפקטיבי; וה-coinbase משלם לכתובת החותם האפקטיבי.

---

## 5. הקצאות יציקה

### 5.1 מוטיבציה

הקצאות יציקה מאפשרות לבעלי plot להאציל סמכות יציקת בלוקים מבלי לוותר על בעלות על ה-plots שלהם. מנגנון זה מאפשר כריית pool והגדרות אחסון קר תוך שמירה על ערבויות האבטחה של PoCX.

בכריית pool, בעלי plot יכולים להרשות ל-pool ליצוק בלוקים בשמם. ה-pool מרכיב בלוקים ומפיץ תגמולים, אך הוא לעולם לא מקבל משמורת על ה-plots עצמם. הקצאה ניתנת לביטול בכל עת, ובעלי plot נשארים חופשיים לעזוב pool או לשנות הגדרות ללא צורך ב-replotting.

הקצאות גם תומכות בהפרדה נקייה בין מפתחות קרים וחמים. המפתח הפרטי השולט ב-plot יכול להישאר במצב לא מקוון, בעוד מפתח יציקה נפרד - המאוחסן על מכונה מקוונת - מייצר בלוקים. פריצה למפתח היציקה אפוא פוגעת רק בסמכות היציקה, לא בבעלות. ה-plot נשאר בטוח וההקצאה ניתנת לביטול, וסוגרת את הפער האבטחתי מיידית.

הקצאות יציקה מספקות אפוא גמישות תפעולית תוך שמירה על העיקרון ששליטה על קיבולת מאוחסנת לעולם לא צריכה לעבור למתווכים.

### 5.2 פרוטוקול הקצאה

הקצאות מוצהרות באמצעות עסקאות OP_RETURN כדי להימנע מצמיחה מיותרת של קבוצת ה-UTXO. עסקת הקצאה מציינת את כתובת ה-plot ואת כתובת היציקה המורשית לייצר בלוקים באמצעות קיבולת אותו plot. עסקת ביטול מכילה רק את כתובת ה-plot. בשני המקרים, בעל ה-plot מוכיח שליטה על ידי חתימה על קלט ההוצאה של העסקה.

כל הקצאה מתקדמת דרך רצף של מצבים מוגדרים היטב (UNASSIGNED, ASSIGNING, ASSIGNED, REVOKING, REVOKED). לאחר שעסקת הקצאה מאושרת, המערכת נכנסת לשלב הפעלה קצר. עיכוב זה - 30 בלוקים, בערך שעה אחת - מבטיח יציבות במהלך מרוצי בלוקים ומונע החלפה מהירה ועוינת של זהויות יציקה. ברגע שתקופת ההפעלה הזו פגה, ההקצאה הופכת לפעילה ונשארת כך עד שבעל ה-plot מנפיק ביטול.

ביטולים עוברים לתקופת עיכוב ארוכה יותר של 720 בלוקים, בערך יום אחד. במהלך זמן זה, כתובת היציקה הקודמת נשארת פעילה. עיכוב ארוך יותר זה מספק יציבות תפעולית ל-pools, מונע "קפיצת הקצאות" אסטרטגית ונותן לספקי תשתית מספיק ודאות לפעול ביעילות. לאחר שעיכוב הביטול פג, הביטול הושלם, ובעל ה-plot חופשי להקצות מפתח יציקה חדש.

מצב ההקצאה נשמר במבנה שכבת-קונצנזוס מקביל לקבוצת ה-UTXO ותומך בנתוני undo לטיפול בטוח בארגון מחדש של שרשרת.

### 5.3 כללי אימות

עבור כל בלוק, מאמתים קובעים את החותם האפקטיבי - הכתובת שחייבת לחתום על הבלוק ולקבל את תגמול ה-coinbase. חותם זה תלוי אך ורק במצב ההקצאה בגובה הבלוק.

אם אין הקצאה או שההקצאה עדיין לא השלימה את שלב ההפעלה שלה, בעל ה-plot נשאר החותם האפקטיבי. ברגע שהקצאה הופכת לפעילה, כתובת היציקה המוקצית חייבת לחתום. במהלך ביטול, כתובת היציקה ממשיכה לחתום עד שעיכוב הביטול פג. רק אז סמכות חוזרת לבעל ה-plot.

מאמתים אוכפים שחתימת הבלוק הופקה על ידי החותם האפקטיבי, שה-coinbase משלם לאותה כתובת, ושכל המעברים עוקבים אחר עיכובי ההפעלה והביטול שנקבעו. רק בעל ה-plot יכול ליצור או לבטל הקצאות; מפתחות יציקה לא יכולים לשנות או להאריך את הרשאותיהם.

הקצאות יציקה מציגות אפוא האצלה גמישה ללא הצגת אמון. בעלות על הקיבולת הבסיסית תמיד נשארת מעוגנת קריפטוגרפית לבעל ה-plot, בעוד סמכות יציקה יכולה להיות מואצלת, מסובבת, או מבוטלת ככל שצרכים תפעוליים מתפתחים.

---

## 6. קנה מידה דינמי

ככל שחומרה מתפתחת, עלות חישוב plots יורדת ביחס לקריאת עבודה מחושבת מראש מדיסק. ללא אמצעי נגד, תוקפים יכלו בסופו של דבר ליצור הוכחות בזמן אמת מהר יותר מאשר כורים הקוראים עבודה מאוחסנת, מערערים את מודל האבטחה של Proof of Capacity.

כדי לשמר את מרווח האבטחה המיועד, PoCX מיישם לוח זמנים לקנה מידה: רמת קנה המידה המינימלית הנדרשת ל-plots עולה עם הזמן. כל רמת קנה מידה Xn, כמתואר בסעיף 3.5, מטמיעה proof-of-work רב יותר באופן אקספוננציאלי בתוך מבנה ה-plot, מבטיחה שכורים ממשיכים להתחייב למשאבי אחסון משמעותיים גם כאשר חישוב הופך זול יותר.

לוח הזמנים מתאים לתמריצים הכלכליים של הרשת, במיוחד halvings של תגמול הבלוק. ככל שהתגמול לכל בלוק יורד, הרמה המינימלית עולה בהדרגה, משמרת את האיזון בין מאמץ plotting לפוטנציאל כרייה:

| תקופה | שנים | Halvings | קנה מידה מינימלי | מכפיל עבודת Plot |
|--------|-------|----------|-------------|---------------------|
| Epoch 0 | 0-4 | 0 | X1 | ×2 מהבסיס |
| Epoch 1 | 4-12 | 1-2 | X2 | ×4 מהבסיס |
| Epoch 2 | 12-28 | 3-6 | X3 | ×8 מהבסיס |
| Epoch 3 | 28-60 | 7-14 | X4 | ×16 מהבסיס |
| Epoch 4 | 60-124 | 15-30 | X5 | ×32 מהבסיס |
| Epoch 5 | 124+ | 31+ | X6 | ×64 מהבסיס |

כורים יכולים אופציונלית להכין plots החורגים מהמינימום הנוכחי ברמה אחת, מאפשר להם לתכנן קדימה ולהימנע משדרוגים מיידיים כאשר הרשת עוברת ל-epoch הבא. שלב אופציונלי זה אינו מעניק יתרון נוסף במונחי הסתברות בלוק - הוא רק מאפשר מעבר תפעולי חלק יותר.

בלוקים המכילים הוכחות מתחת לרמת קנה המידה המינימלית עבור גובהם נחשבים לא תקפים. מאמתים בודקים את רמת קנה המידה המוצהרת בהוכחה מול דרישת הרשת הנוכחית במהלך אימות קונצנזוס, מבטיחים שכל הכורים המשתתפים עומדים בציפיות האבטחה המתפתחות.

---

## 7. ארכיטקטורת כרייה

PoCX מפריד בין פעולות קריטיות לקונצנזוס לבין משימות עתירות-משאבים של כרייה, מאפשר גם אבטחה וגם יעילות. הצומת מתחזק את ה-blockchain, מאמת בלוקים, מנהל את ה-mempool, וחושף ממשק RPC. כורים חיצוניים מטפלים באחסון plot, קריאת scoop, חישוב איכות, וניהול deadline. הפרדה זו שומרת על לוגיקת הקונצנזוס פשוטה וניתנת לביקורת תוך אפשור לכורים לבצע אופטימיזציה לתפוקת דיסק.

### 7.1 ממשק RPC לכרייה

כורים מתקשרים עם הצומת באמצעות סט מינימלי של קריאות RPC. קריאת get_mining_info RPC מספקת את גובה הבלוק הנוכחי, generation signature, base target, deadline יעד, וטווח רמות קנה מידה של plot מקובלות. באמצעות מידע זה, כורים מחשבים nonces מועמדים. קריאת submit_nonce RPC מאפשרת לכורים להגיש פתרון מוצע, כולל מזהה plot, אינדקס nonce, רמת קנה מידה, וחשבון כורה. הצומת מעריך את ההגשה ומגיב עם ה-deadline המחושב אם ההוכחה תקפה.

### 7.2 מתזמן יציקה

הצומת מתחזק מתזמן יציקה, העוקב אחר הגשות נכנסות ושומר רק על הפתרון הטוב ביותר לכל גובה בלוק. nonces שהוגשו ממתינים בתור עם הגנות מובנות נגד הצפת הגשות או התקפות denial-of-service. המתזמן ממתין עד שה-deadline המחושב פג או פתרון עדיף מגיע, ובנקודה זו הוא מרכיב בלוק, חותם עליו באמצעות מפתח היציקה האפקטיבי, ומפרסם אותו לרשת.

### 7.3 יציקה הגנתית

כדי למנוע התקפות תזמון או תמריצים למניפולציה של שעון, PoCX מיישם יציקה הגנתית. אם בלוק מתחרה מגיע לאותו גובה, המתזמן משווה את הפתרון המקומי עם הבלוק החדש. אם האיכות המקומית עדיפה, הצומת יוצק מיידית במקום להמתין ל-deadline המקורי. זה מבטיח שכורים לא יכולים לזכות ביתרון רק על ידי התאמת שעונים מקומיים; הפתרון הטוב ביותר תמיד מנצח, שומר על הוגנות ואבטחת רשת.

---

## 8. ניתוח אבטחה

### 8.1 מודל איומים

PoCX מדגמן יריבים עם יכולות משמעותיות אך מוגבלות. תוקפים עשויים לנסות להעמיס על הרשת עסקאות לא תקפות, בלוקים פגומים, או הוכחות מזויפות כדי לבחון נתיבי אימות במצבי לחץ. הם יכולים לתמרן בחופשיות את השעונים המקומיים שלהם ועשויים לנסות לנצל מקרי קצה בהתנהגות קונצנזוס כגון טיפול בחותמות זמן, דינמיקת התאמת קושי, או כללי ארגון מחדש. יריבים צפויים גם לחפש הזדמנויות לשכתב היסטוריה באמצעות פיצולי שרשרת ממוקדים.

המודל מניח שאף צד בודד אינו שולט ברוב קיבולת האחסון הכוללת של הרשת. כמו בכל מנגנון קונצנזוס מבוסס משאבים, תוקף עם 51% קיבולת יכול לארגן מחדש את השרשרת באופן חד-צדדי; מגבלה בסיסית זו אינה ייחודית ל-PoCX. PoCX גם מניח שתוקפים לא יכולים לחשב נתוני plot מהר יותר מאשר כורים ישרים יכולים לקרוא אותם מדיסק. לוח הזמנים לקנה מידה (סעיף 6) מבטיח שהפער החישובי הנדרש לאבטחה גדל עם הזמן ככל שחומרה משתפרת.

הסעיפים הבאים בוחנים כל קטגוריית התקפה עיקרית בפירוט ומתארים את אמצעי הנגד המובנים ב-PoCX.

### 8.2 התקפות קיבולת

כמו PoW, תוקף עם רוב קיבולת יכול לשכתב היסטוריה (התקפת 51%). השגת זאת דורשת רכישת טביעת רגל אחסון פיזית גדולה מהרשת הישרה - התחייבות יקרה ותובענית לוגיסטית. לאחר שהחומרה נרכשת, עלויות התפעול נמוכות, אך ההשקעה הראשונית יוצרת תמריץ כלכלי חזק להתנהגות ישרה: ערעור השרשרת יפגע בערך בסיס הנכסים של התוקף עצמו.

PoC גם נמנע מבעיית nothing-at-stake הקשורה ל-PoS. למרות שכורים יכולים לסרוק plots נגד פיצולים מתחרים מרובים, כל סריקה צורכת זמן אמיתי - בדרך כלל בסדר גודל של עשרות שניות לשרשרת. עם מרווח בלוקים של 120 שניות, זה מגביל מטבעו כריית פיצולים מרובים, וניסיון לכרות פיצולים רבים בו-זמנית פוגע בביצועים על כולם. כריית פיצולים אינה אפוא ללא עלות; היא מוגבלת מהותית על ידי תפוקת I/O.

גם אם חומרה עתידית תאפשר סריקת plot כמעט מיידית (למשל, SSDs במהירות גבוהה), תוקף עדיין יעמוד בפני דרישת משאבים פיזיים משמעותית לשליטה ברוב קיבולת הרשת, מה שהופך התקפה בסגנון 51% ליקרה ומאתגרת לוגיסטית.

לבסוף, התקפות קיבולת הרבה יותר קשות להשכרה מאשר התקפות hashpower. חישוב GPU ניתן לרכישה לפי דרישה ולהפניה מיידית לכל שרשרת PoW. לעומת זאת, PoC דורש חומרה פיזית, plotting עתיר-זמן, ופעולות I/O מתמשכות. אילוצים אלו הופכים התקפות אופורטוניסטיות קצרות-טווח להרבה פחות אפשריות.

### 8.3 התקפות תזמון

תזמון ממלא תפקיד קריטי יותר ב-Proof of Capacity מאשר ב-Proof of Work. ב-PoW, חותמות זמן משפיעות בעיקר על התאמת קושי; ב-PoC, הן קובעות האם ה-deadline של כורה עבר ואם בלוק זכאי ליציקה. Deadlines נמדדים ביחס לחותמת הזמן של בלוק האב, אך השעון המקומי של הצומת משמש לשפוט האם בלוק נכנס שוכן רחוק מדי בעתיד. מסיבה זו PoCX אוכף סובלנות חותמת זמן הדוקה: בלוקים לא יכולים לסטות יותר מ-15 שניות מהשעון המקומי של הצומת (בהשוואה לחלון של שעתיים ב-Bitcoin). גבול זה עובד בשני הכיוונים - בלוקים רחוקים מדי בעתיד נדחים, וצמתים עם שעונים איטיים עשויים לדחות בטעות בלוקים תקפים נכנסים.

צמתים צריכים אפוא לסנכרן את שעוניהם באמצעות NTP או מקור זמן שווה ערך. PoCX נמנע בכוונה מהסתמכות על מקורות זמן פנימיים לרשת כדי למנוע מתוקפים לתמרן זמן רשת נתפס. צמתים מנטרים את הסחף שלהם ומפיקים אזהרות אם השעון המקומי מתחיל לסטות מחותמות זמן של בלוקים אחרונים.

האצת שעון - הפעלת שעון מקומי מהיר ליציקה מעט מוקדמת יותר - מספקת רק יתרון שולי. בתוך הסובלנות המותרת, יציקה הגנתית (סעיף 7.3) מבטיחה שכורה עם פתרון טוב יותר יפרסם מיידית לאחר ראיית בלוק מוקדם נחות. שעון מהיר רק עוזר לכורה לפרסם פתרון שכבר מנצח כמה שניות מוקדם יותר; הוא לא יכול להפוך הוכחה נחותה למנצחת.

ניסיונות לתמרן קושי באמצעות חותמות זמן מוגבלים על ידי מכסת התאמה של ±20% לכל בלוק וחלון גלגול של 24 בלוקים, מונעים מכורים להשפיע משמעותית על קושי באמצעות משחקי תזמון קצרי-טווח.

### 8.4 התקפות Time-Memory Tradeoff

time-memory tradeoffs מנסים להפחית דרישות אחסון על ידי חישוב מחדש של חלקים מה-plot לפי דרישה. מערכות Proof of Capacity קודמות היו פגיעות להתקפות כאלו, בעיקר פגם חוסר-איזון scoop של POC1 והתקפת דחיסת XOR-transpose של POC2 (סעיף 2.4). שניהם ניצלו א-סימטריות במידת היוקר של התחדשות חלקים מסוימים של נתוני plot, אפשרו ליריבים לחתוך אחסון תוך תשלום עונש חישובי קטן בלבד. כמו כן, פורמטי plot חלופיים ל-PoC2 סובלים מחולשות TMTO דומות; דוגמה בולטת היא Chia, שפורמט ה-plot שלה ניתן לצמצום שרירותי בגורם הגדול מ-4.

PoCX מסיר משטחי התקפה אלו לחלוטין באמצעות בניית ה-nonce ופורמט ה-warp שלו. בתוך כל nonce, שלב הדיפוזיה הסופי מחיל hash על המאגר המחושב במלואו ומבצע XOR של התוצאה לאורך כל הבתים, מבטיח שכל חלק מהמאגר תלוי בכל חלק אחר ולא ניתן לקיצור דרך. לאחר מכן, ה-shuffle של PoC2 מחליף את החצאים התחתון והעליון של כל scoop, משווה את העלות החישובית של שחזור כל scoop.

PoCX מבטל עוד יותר את התקפת דחיסת XOR-transpose של POC2 על ידי גזירת פורמט X1 המוקשח שלו, שבו כל scoop הוא ה-XOR של מיקום ישיר ומיקום מועבר לאורך warps מזווגים; זה מקשר כל scoop עם שורה שלמה ועמודה שלמה של נתוני X0 בסיסיים, הופך שחזור לדרוש אלפי nonces מלאים ובכך מסיר את ה-time-memory tradeoff הא-סימטרי לחלוטין.

כתוצאה מכך, אחסון ה-plot המלא הוא האסטרטגיה היחידה הכדאית מבחינה חישובית עבור כורים. אין קיצור דרך ידוע - בין אם plotting חלקי, התחדשות סלקטיבית, דחיסה מבנית, או גישות היברידיות של חישוב-אחסון - המספק יתרון משמעותי. PoCX מבטיח שכרייה נשארת מוגבלת-אחסון לחלוטין ושקיבולת משקפת מחויבות פיזית אמיתית.

### 8.5 התקפות הקצאה

PoCX משתמש במכונת מצבים דטרמיניסטית לשליטה בכל הקצאות plot-ל-יוצק. כל הקצאה מתקדמת דרך מצבים מוגדרים היטב - UNASSIGNED → ASSIGNING → ASSIGNED → REVOKING → REVOKED - עם עיכובי הפעלה וביטול נאכפים. זה מבטיח שכורה לא יכול לשנות הקצאות מיידית כדי לרמות את המערכת או להחליף במהירות סמכות יציקה.

מכיוון שכל המעברים דורשים הוכחות קריפטוגרפיות - במיוחד, חתימות על ידי בעל ה-plot הניתנות לאימות מול קלט ה-UTXO - הרשת יכולה לסמוך על הלגיטימיות של כל הקצאה. ניסיונות לעקוף את מכונת המצבים או לזייף הקצאות נדחים אוטומטית במהלך אימות קונצנזוס. התקפות replay נמנעות באופן דומה על ידי הגנות replay עסקאות בסגנון Bitcoin סטנדרטי, מבטיחות שכל פעולת הקצאה קשורה באופן ייחודי לקלט תקף שלא נוצל.

השילוב של ניהול מכונת מצבים, עיכובים נאכפים, והוכחה קריפטוגרפית הופך רמאות מבוססת-הקצאה לכמעט בלתי אפשרית: כורים לא יכולים לחטוף הקצאות, לבצע הקצאה מחדש מהירה במהלך מרוצי בלוקים, או לעקוף לוחות זמנים של ביטול.

### 8.6 אבטחת חתימה

חתימות בלוק ב-PoCX משמשות כקישור קריטי בין הוכחה למפתח היציקה האפקטיבי, מבטיחות שרק כורים מורשים יכולים לייצר בלוקים תקפים.

כדי למנוע התקפות malleability, חתימות אינן נכללות בחישוב hash הבלוק. זה מבטל סיכונים של חתימות ניתנות לעיבוד שעלולות לערער אימות או לאפשר התקפות החלפת בלוק.

כדי להפחית וקטורי denial-of-service, גדלי חתימה ומפתח ציבורי קבועים - 65 בתים לחתימות קומפקטיות ו-33 בתים למפתחות ציבוריים דחוסים - מונעים מתוקפים לנפח בלוקים כדי לגרום לדלדול משאבים או להאט התפשטות רשת.

---

## 9. יישום

PoCX מיושם כהרחבה מודולרית ל-Bitcoin Core, כאשר כל הקוד הרלוונטי נמצא בתוך תת-ספרייה ייעודית משלו ומופעל באמצעות feature flag. עיצוב זה משמר את שלמות הקוד המקורי, מאפשר הפעלה או השבתה נקייה של PoCX, מה שמפשט בדיקות, ביקורת, והישארות מסונכרנת עם שינויים ב-upstream.

השילוב נוגע רק בנקודות החיוניות הנדרשות לתמיכה ב-Proof of Capacity. כותרת הבלוק הורחבה לכלול שדות ספציפיים ל-PoCX, ואימות קונצנזוס הותאם לעיבוד הוכחות מבוססות-אחסון לצד בדיקות Bitcoin מסורתיות. מערכת היציקה, האחראית לניהול deadlines, תזמון, והגשות כורים, נמצאת לחלוטין בתוך מודולי PoCX, בעוד הרחבות RPC חושפות פונקציונליות כרייה והקצאה ללקוחות חיצוניים. עבור משתמשים, ממשק הארנק שופר לניהול הקצאות באמצעות עסקאות OP_RETURN, מאפשר אינטראקציה חלקה עם תכונות הקונצנזוס החדשות.

כל הפעולות הקריטיות לקונצנזוס מיושמות ב-C++ דטרמיניסטי ללא תלויות חיצוניות, מבטיחות עקביות חוצת-פלטפורמות. Shabal256 משמש ל-hashing, בעוד Time Bending וחישוב איכות מסתמכים על אריתמטיקה של נקודה קבועה ופעולות 256 ביט. פעולות קריפטוגרפיות כגון אימות חתימה ממנפות את ספריית secp256k1 הקיימת של Bitcoin Core.

על ידי בידוד פונקציונליות PoCX בדרך זו, היישום נשאר ניתן לביקורת, לתחזוקה, ותואם לחלוטין לפיתוח מתמשך של Bitcoin Core, מדגים שמנגנון קונצנזוס מוגבל-אחסון חדש מהותית יכול להתקיים יחד עם בסיס קוד proof-of-work בשל מבלי לשבש את שלמותו או שימושיותו.

---

## 10. פרמטרי רשת

PoCX בונה על תשתית הרשת של Bitcoin ומשתמש מחדש במסגרת פרמטרי השרשרת שלו. כדי לתמוך בכרייה מבוססת-קיבולת, טיפול בהקצאות, וקנה מידה של plot, מספר פרמטרים הורחבו או נדרסו. זה כולל יעד זמן בלוק, סובסידיה ראשונית, לוח זמנים של halving, עיכובי הפעלה וביטול הקצאה, וכן מזהי רשת כגון magic bytes, פורטים, ותחיליות Bech32. סביבות testnet ו-regtest מתאימות עוד יותר פרמטרים אלו לאפשר איטרציה מהירה ובדיקות בקיבולת נמוכה.

הטבלאות להלן מסכמות את הגדרות mainnet, testnet, ו-regtest המתקבלות, מדגישות כיצד PoCX מתאים את פרמטרי הליבה של Bitcoin למודל קונצנזוס מוגבל-אחסון.

### 10.1 Mainnet

| פרמטר | ערך |
|-----------|-------|
| Magic bytes | `0xa7 0x3c 0x91 0x5e` |
| פורט ברירת מחדל | 8888 |
| Bech32 HRP | `pocx` |
| יעד זמן בלוק | 120 שניות |
| סובסידיה ראשונית | 10 BTC |
| מרווח halving | 1050000 בלוקים (~4 שנים) |
| היצע כולל | ~21 מיליון BTC |
| הפעלת הקצאה | 30 בלוקים |
| ביטול הקצאה | 720 בלוקים |
| חלון גלגול | 24 בלוקים |

### 10.2 Testnet

| פרמטר | ערך |
|-----------|-------|
| Magic bytes | `0x6d 0xf2 0x48 0xb3` |
| פורט ברירת מחדל | 18888 |
| Bech32 HRP | `tpocx` |
| יעד זמן בלוק | 120 שניות |
| פרמטרים אחרים | זהים ל-mainnet |

### 10.3 Regtest

| פרמטר | ערך |
|-----------|-------|
| Magic bytes | `0xfa 0xbf 0xb5 0xda` |
| פורט ברירת מחדל | 18444 |
| Bech32 HRP | `rpocx` |
| יעד זמן בלוק | שנייה אחת |
| מרווח halving | 500 בלוקים |
| הפעלת הקצאה | 4 בלוקים |
| ביטול הקצאה | 8 בלוקים |
| מצב קיבולת נמוכה | מופעל (plots של ~4 MB) |

---

## 11. עבודות קשורות

לאורך השנים, מספר פרויקטי blockchain וקונצנזוס חקרו מודלים של כרייה מבוססי-אחסון או היברידיים. PoCX בונה על מורשת זו תוך הצגת שיפורים באבטחה, יעילות, ותאימות.

**Burstcoin / Signum.** Burstcoin הציג את מערכת ה-Proof-of-Capacity (PoC) המעשית הראשונה ב-2014, הגדיר מושגי ליבה כגון plots, nonces, scoops, וכרייה מבוססת-deadline. יורשיו, בעיקר Signum (לשעבר Burstcoin), הרחיבו את האקוסיסטם ובסופו של דבר התפתחו למה שמכונה Proof-of-Commitment (PoC+), משלב מחויבות אחסון עם staking אופציונלי להשפעה על קיבולת אפקטיבית. PoCX יורש את יסודות כריית האחסון מפרויקטים אלו, אך מתבדל משמעותית באמצעות פורמט plot מוקשח (קידוד XOR-transpose), קנה מידה דינמי של עבודת-plot, החלקת deadline ("Time Bending"), ומערכת הקצאות גמישה - כל זאת תוך עיגון בבסיס הקוד של Bitcoin Core במקום תחזוקת fork רשת עצמאי.

**Chia.** Chia מיישם Proof of Space and Time, משלב הוכחות אחסון מבוססות-דיסק עם רכיב זמן הנאכף באמצעות Verifiable Delay Functions (VDFs). העיצוב שלו מתמודד עם חששות מסוימים לגבי שימוש חוזר בהוכחות ויצירת אתגר רענן, שונה מ-PoC קלאסי. PoCX אינו מאמץ את מודל ההוכחה המעוגן-בזמן; במקום זאת, הוא שומר על קונצנזוס מוגבל-אחסון עם מרווחים צפויים, מותאם לתאימות לטווח ארוך עם כלכלת UTXO וכלים הנגזרים מ-Bitcoin.

**Spacemesh.** Spacemesh מציע סכמת Proof-of-Space-Time (PoST) המשתמשת בטופולוגיית רשת מבוססת DAG (mesh). במודל זה, משתתפים חייבים להוכיח מעת לעת שאחסון שהוקצה נשאר שלם לאורך זמן, במקום להסתמך על מערך נתונים מחושב מראש יחיד. PoCX, לעומת זאת, מאמת מחויבות אחסון רק בזמן בלוק - עם פורמטי plot מוקשחים ואימות הוכחה קפדני - נמנע מתקורת הוכחות אחסון רציפות תוך שמירה על יעילות וביזור.

---

## 12. סיכום

Bitcoin-PoCX מדגים שקונצנזוס חסכוני באנרגיה יכול להשתלב ב-Bitcoin Core תוך שמירה על תכונות אבטחה ומודל כלכלי. תרומות מרכזיות כוללות קידוד XOR-transpose (מכריח תוקפים לחשב 4096 nonces לכל חיפוש, מבטל את התקפת הדחיסה), אלגוריתם Time Bending (טרנספורמציית התפלגות מפחיתה שונות בזמני בלוק), מערכת הקצאות יציקה (האצלה מבוססת OP_RETURN מאפשרת כריית pool ללא משמורת), קנה מידה דינמי (מיושר עם halvings לשמירה על מרווחי אבטחה), ושילוב מינימלי (קוד מבוסס-feature-flag מבודד בספרייה ייעודית).

המערכת נמצאת כעת בשלב testnet. כוח כרייה נגזר מקיבולת אחסון במקום קצב hash, מפחית צריכת אנרגיה בסדרי גודל תוך שמירה על המודל הכלכלי המוכח של Bitcoin.

---

## הפניות

Bitcoin Core. *Bitcoin Core Repository.* https://github.com/bitcoin/bitcoin

Burstcoin. *Proof of Capacity Technical Documentation.* 2014.

NIST. *SHA-3 Competition: Shabal.* 2008.

Cohen, B., Pietrzak, K. *The Chia Network Blockchain.* 2019.

Spacemesh. *Spacemesh Protocol Documentation.* 2021.

PoC Consortium. *PoCX Framework.* https://github.com/PoC-Consortium/pocx

PoC Consortium. *Bitcoin-PoCX Integration.* https://github.com/PoC-Consortium/bitcoin-pocx

---

**רישיון**: MIT
**ארגון**: Proof of Capacity Consortium
**סטטוס**: שלב Testnet
